{
  "id": "nodes/94dc38c3-c3c8-4e86-b5f0-6bc0e1d5a9af",
  "name": "visit_Call",
  "node_type": "function",
  "qname": "Jarvis.processing.extProcessor.ExtProcessor.visit_Call",
  "file_path": "/Users/yared/Documents/Programing/personal/pythonJaRvis.github.io/Jarvis/tool/Jarvis/processing/extProcessor.py",
  "file_name": "extProcessor",
  "code": "def visit_Call(self, node, decorator=False, decoratorParam=None):\n    \"\"\"ID: 94dc38c3-c3c8-4e86-b5f0-6bc0e1d5a9af\"\"\"\n    def resolve_call():\n        \"\"\"ID: fd9ea3dd-0a19-4a26-9629-43341b7dd127\"\"\"\n        if decorator:\n            if isinstance(node, ast.Name):\n                self.visit(node)\n                if getattr(node, \"id\", None) and self.is_builtin(node.id):\n                    name = utils.join_ns(\n                        utils.constants.BUILTIN_NAME, node.id)\n                    defi = self.def_manager.get(name)\n                    if not defi:\n                        self.def_manager.create(\n                            name, utils.constants.FUN_DEF)\n                    return [name]\n                else:\n                    curDefi: Definition = self.scope_manager.get_def(\n                        self.current_ns, node.id\n                    )\n                    if not curDefi:\n                        return []\n                    # callDefiNsList = self.getPoint(curDefi.get_ns())\n                    callDefiNsList = self.getYPOint(\n                        1000, [curDefi.get_ns()])\n                    return callDefiNsList\n                pass\n            elif isinstance(node, ast.Attribute):\n                self.visit(node)\n                field = node.attr\n                xDefiList = self.decode_node(node.value)\n                XPointList = (\n                    self.getYPOint(\n                        node.lineno, xDefiList) if xDefiList else []\n                )\n                xFieldList = list(\n                    filter(\n                        lambda x: x,\n                        (map(lambda x: self.find_field(x, field), XPointList)),\n                    )\n                )\n                return self.getYPOint(node.lineno, xFieldList)\n                pass\n            elif isinstance(node, ast.Call):\n                self.visit(node)\n                xDefiList = self.decode_node(node)\n                xRetList = self.getYPOint(node.lineno, xDefiList)\n                return xRetList\n            elif isinstance(node, ast.Subscript):\n                # Calls can be performed only on single indices, not ranges\n                full_names = self.retrieve_subscript_names(node)\n                return [full_names]\n            return\n        if isinstance(node.func, ast.Name):\n            self.visit(node.func)\n            if getattr(node.func, \"id\", None) and self.is_builtin(node.func.id):\n                name = utils.join_ns(\n                    utils.constants.BUILTIN_NAME, node.func.id)\n                defi = self.def_manager.get(name)\n                if not defi:\n                    self.def_manager.create(name, utils.constants.FUN_DEF)\n                return [name]\n            else:\n                curDefi: Definition = self.scope_manager.get_def(\n                    self.current_ns, node.func.id\n                )\n                if not curDefi:\n                    return []\n                # callDefiNsList = self.getPoint(curDefi.get_ns())\n                callDefiNsList = self.getYPOint(1000, [curDefi.get_ns()])\n                return callDefiNsList\n            pass\n        elif isinstance(node.func, ast.Attribute):\n            self.visit(node.func)\n            field = node.func.attr\n            xDefiList = self.decode_node(node.func.value)\n            XPointList = self.getYPOint(\n                node.lineno, xDefiList) if xDefiList else []\n            xFieldList = list(\n                filter(\n                    lambda x: x,\n                    (map(lambda x: self.find_field(x, field), XPointList)),\n                )\n            )\n            for XPoint in XPointList:\n                Xdefi = self.def_manager.get(XPoint)\n                if isinstance(Xdefi, Definition) and Xdefi.get_type() == utils.constants.MAP_DEF:\n                    if field in ['update']:\n                        for index, param in enumerate(node.args):\n                            if isinstance(param, ast.Dict):\n                                for index, v in enumerate(param.values):\n                                    decoded = self.decode_node(v)\n                                    values = self.getYPOint(\n                                        node.lineno, decoded)\n                                # for v in param.values:\n                                #     values = self.getYPOint(node.lineno,v)\n                                    Xdefi.set_element(index, values)\n                        # XPoint.add_value_point()\n            return self.getYPOint(node.lineno, xFieldList)\n            pass\n        elif isinstance(node.func, ast.Call):\n            self.visit(node.func)\n            xDefiList = self.decode_node(node.func)\n            xRetList = self.getYPOint(node.lineno, xDefiList)\n            return xRetList\n        elif isinstance(node.func, ast.Subscript):\n            # Calls can be performed only on single indices, not ranges\n            full_names = self.retrieve_subscript_names(node.func)\n            # return [full_names]\n            return full_names\n        return [None]\n\n    def format_call(call):\n        \"\"\"ID: 9f0a0e57-4eb5-4d7e-9ccb-13e49644e0ac\"\"\"\n        callDefi: Definition = self.def_manager.get(call)\n        if callDefi and callDefi.get_type() == utils.constants.CLS_DEF:\n            # clsCopyNs = self.new(call,node.lineno)\n            clsInit = utils.join_ns(call, utils.constants.CLS_INIT)\n            clsDefi = self.def_manager.get(clsInit)\n            if clsDefi:\n                return clsInit\n            else:\n                return None\n        # if callDefi and callDefi.get_type() == utils.constants.FUN_DEF:\n        #     return call\n        return call\n\n    def match_call(call):\n        \"\"\"ID: 54664d41-3f49-4c9a-8663-00498572c6c8\"\"\"\n        if decorator:\n            callDefi: Definition = self.def_manager.get(call)\n            if not callDefi:\n                # self.cg.add_edge(self.current_ns, call)\n                return\n            callScope: ScopeItem = self.scope_manager.get_scope(call)\n            if not callScope:\n                return\n            moduleNs = self.get_module_ns(callScope.get_ns())\n            method = self.module_manager.get_func_name(\n                moduleNs, callScope.get_ns())\n            if not method:\n                line = node.lineno\n            else:\n                line = method[\"first\"]\n            paramList = callScope.params\n            argList = decoratorParam\n            paramsMap = {}\n            for index, param in enumerate(decoratorParam):\n                if index >= len(argList):\n                    break\n                if index >= len(paramList):\n                    break\n                if isinstance(param, str) or isinstance(param, list):\n                    paramsMap[paramList[index].get_ns()] = param\n                elif isinstance(param, Definition):\n                    paramsMap[paramList[index].get_ns()] = param.get_ns()\n                elif isinstance(param, dict):\n                    for k, v in param.items():\n                        if not k:\n                            continue\n                        paramsMap[utils.join_ns(callScope.get_ns(), k)] = v\n            for param, arg in paramsMap.items():\n                paramDefi: Definition = self.def_manager.get(param)\n                if (\n                        not paramDefi\n                        or not paramDefi.get_type() == utils.constants.PARAM_DEF\n                ):\n                    continue\n                if isinstance(arg, str):\n                    argsPoint = self.getYPOint(node.lineno, [arg])\n                elif isinstance(arg, list) and arg:\n                    # argsPoint = reduce(lambda x, y: x + y, map(lambda x: self.getPoint(x), arg))\n                    argsPoint = self.getYPOint(node.lineno, [arg])\n                elif isinstance(arg, ScopeItem):\n                    # argsPoint = self.getPoint(arg.get_ns())\n                    argsPoint = self.getYPOint(node.lineno, [arg])\n                paramDefi.add_value_point(line, argsPoint)\n\n            return\n        callDefi: Definition = self.def_manager.get(call)\n        if not callDefi:\n            # self.cg.add_edge(self.current_ns,call)\n            return\n        callScope: ScopeItem = self.scope_manager.get_scope(call)\n        argList = self._handle_args(node)\n        if not callScope:\n            return\n        moduleNs = self.get_module_ns(callScope.get_ns())\n        method = self.module_manager.get_func_name(\n            moduleNs, callScope.get_ns())\n        if not method:\n            line = node.lineno\n        else:\n            line = method[\"first\"]\n        paramList = callScope.params\n        paramsMap = {}\n        for index, param in enumerate(argList):\n            if index >= len(argList):\n                break\n            if isinstance(param, str) or isinstance(param, list):\n                if index >= len(paramList):\n                    break\n                paramsMap[paramList[index].get_ns()] = param\n            elif isinstance(param, ScopeItem):\n                paramsMap[paramList[index].get_ns()] = param\n            elif isinstance(param, dict):\n                for k, v in param.items():\n                    if not k:\n                        continue\n                    paramsMap[utils.join_ns(callScope.get_ns(), k)] = v\n        for param, arg in paramsMap.items():\n            paramDefi: Definition = self.def_manager.get(param)\n            if (\n                    not paramDefi\n                    or not paramDefi.get_type() == utils.constants.PARAM_DEF\n            ):\n                continue\n            if isinstance(arg, str):\n                # argsPoint = self.getYPOint(node.lineno, [arg])\n                # argsPoint = self.getPoint(arg)\n                argsPoint = self.getYPOint(node.lineno, [arg])\n            elif isinstance(arg, list) and arg:\n                # argsPoint = reduce(lambda x, y: x + y, map(lambda x: self.getPoint(x), arg))\n                argsPoint = self.getYPOint(node.lineno, arg)\n            elif isinstance(arg, ScopeItem):\n                # argsPoint = self.getPoint(arg.get_ns())\n                argsPoint = self.getYPOint(node.lineno, [arg])\n            else:\n                continue\n            paramDefi.add_value_point(line, argsPoint)\n\n    def enter_call(call: str):\n        \"\"\"ID: 6431682b-631d-4f92-8555-bf9bca7fe4e6\"\"\"\n        # self.cg.add_edge(self.current_ns, call)\n        callDefi: Definition = self.def_manager.get(call)\n        if callDefi and callDefi.get_type() != utils.constants.EXT_DEF:\n            self.cg.add_edge(self.current_ns, call)\n        tmp = reduce(\n            lambda x, y: x or y, map(\n                lambda x: x in call, utils.constants.BUILTTYPE)\n        )\n        if not callDefi and tmp:\n            self.cg.add_edge(self.current_ns, call)\n        self.pushStack(callDefi)\n        pass\n\n    def merge_change(callList):\n        \"\"\"ID: fef56969-c486-42db-a632-0366d50ed01c\"\"\"\n        outPoint = {}\n        for call in callList:\n            callChange: dict = self.change_manager.getChange(call)\n            if not callChange:\n                continue\n            for key, point in callChange.items():\n                if key in outPoint:\n                    outPoint[key] = outPoint[key].union(\n                        point.get_last_point_value()\n                    )\n                if key not in outPoint:\n                    outPoint[key] = point.get_last_point_value()\n        out = {}\n        for key, point in outPoint.items():\n            out[key] = ChangeItem(node.lineno, point)\n        return out\n\n    def update_change(change: dict):\n        \"\"\"ID: 15c4a2ad-7c68-4189-ae07-53c008039503\"\"\"\n        for key, change in change.items():\n            scopens = self.get_scope_ns(key)\n            if not scopens:\n                return\n            scope: ScopeItem = self.scope_manager.get_scope(scopens)\n            if not scope:\n                return\n            field = key[len(scopens) + 1:]\n            defi: Definition = self.def_manager.get(key)\n            if not defi:\n                defi = self.def_manager.create(\n                    key, utils.constants.NAME_DEF)\n            defi.add_value_point(\n                node.lineno, change.get_last_point_value())\n            scope.add_def(field, defi)\n        pass\n    # def builtin_function(func):\n    #     if func == \"<map>.update\":\n\n    # if hasattr(node, \"func\"):\n    #     self.visit(node.func)\n    callList = resolve_call()\n    callList = filter(lambda x: x, callList)\n    callList = list(filter(lambda x: x, map(format_call, callList)))\n    # list(map(match_call, callList))\n    list(map(match_call, callList))\n    list(map(enter_call, callList))\n    if not callList:\n        if hasattr(node, \"args\"):\n            self._handle_args(node)\n\n    changeDict = merge_change(callList)\n    for key, change in changeDict.items():\n        self.change_manager.addChange(\n            self.current_ns, key, node.lineno, change.get_last_point_value()\n        )\n    update_change(changeDict)\n",
  "position": {
    "line_no": 1191,
    "col_offset": 4,
    "end_line_no": 1494,
    "end_col_offset": 0
  }
}