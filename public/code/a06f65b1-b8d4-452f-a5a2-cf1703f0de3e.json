{
  "id": "nodes/a06f65b1-b8d4-452f-a5a2-cf1703f0de3e",
  "name": "extProcessor",
  "node_type": "file",
  "qname": "Jarvis.processing.extProcessor",
  "file_path": "/Users/yared/Documents/Programing/personal/pythonJaRvis.github.io/Jarvis/tool/Jarvis/processing/extProcessor.py",
  "file_name": "extProcessor",
  "code": "# Copyright [pythonJaRvis] [name of copyright owner]\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"FileID: a06f65b1-b8d4-452f-a5a2-cf1703f0de3e\"\"\"\nimport ast\nfrom machinery.definitions import (\n    Definition,\n    DefinitionManager,\n    ChangeManager,\n    ChangeItem,\n)\nfrom machinery.classes import ClassManager, ClassNode\nfrom machinery.scopes import ScopeManager, ScopeItem\nfrom processing.base import ProcessingBase\nfrom machinery.imports import ImportManager\nfrom machinery.nodes import NodeManager\nfrom machinery.modules import ModuleManager, Module\nfrom machinery import gol\n\nimport utils\nfrom functools import reduce\nfrom machinery.callgraph import CallGraph\n\n\nclass ExtProcessor(ProcessingBase):\n    \"\"\"ID: 8687d8b7-db03-428b-802f-20de62884e76\"\"\"\n\n    def __init__(\n            self,\n            filename,\n            modname,\n            import_manager,\n            scope_manager,\n            def_manager,\n            class_manager,\n            module_manager,\n            change_manager,\n            node_manager,\n            cg,\n            callStack=[],\n            visited_scope=set(),\n            modules_analyzed=None,\n            decy=True,\n    ):\n        \"\"\"ID: b05d9cac-1fa9-4199-8d66-999f463b045c\"\"\"\n        if filename.endswith(\".so\") or filename.endswith(\"unicode.py\"):\n            self.import_manager = None\n            self.modules_analyzed = set()\n            self.filename = None\n            return\n        super().__init__(filename, modname, modules_analyzed)\n        self.modname = modname\n        if self.current_ns:\n            imp = self.get_module_ns(self.current_ns)\n            self.modname = imp.name\n            self.filename = imp.filename\n        self.mod_dir = \"/\".join(self.filename.split(\"/\")[:-1])\n        self.import_manager: ImportManager = import_manager\n        self.scope_manager: ScopeManager = scope_manager\n        self.def_manager: DefinitionManager = def_manager\n        self.class_manager: ClassManager = class_manager\n        self.module_manager: ModuleManager = module_manager\n        self.change_manager: ChangeManager = change_manager\n        self.node_manager: NodeManager = node_manager\n        self.match = {}\n        self.decy = decy\n        self.cg: CallGraph = cg\n        self.callStack = callStack\n        self.visited_scope = visited_scope\n\n    def flatten(self, a):\n        \"\"\"ID: 54444063-0587-44cb-bf82-0d0259efeefd\"\"\"\n        if not isinstance(a, (list,)):\n            return [a]\n        else:\n            b = []\n            for item in a:\n                b += self.flatten(item)\n        return b\n\n    def getYPOint(self, row, yList):\n        \"\"\"ID: b7b220b6-dd48-45cc-b823-fda1e70661f1\"\"\"\n        def closure():\n            \"\"\"ID: 4419fdf4-5af4-4c12-af87-c401a645b3fd\"\"\"\n            def func(callee):\n                \"\"\"ID: 996b570d-3fca-4409-a164-5b44d3a5e96d\"\"\"\n                if isinstance(callee, Definition):\n                    callee = callee.get_ns()\n                if isinstance(callee, ScopeItem):\n                    callee = callee.get_ns()\n                return self.resolve(callee, row)\n\n            return func\n\n        if not isinstance(yList, list):\n            yList = [yList]\n        yList = self.flatten(yList)\n        yList = list(filter(lambda x: x, yList))\n        if not yList:\n            return []\n        return reduce(lambda x, y: x + y, map(closure(), yList))\n\n    def pushStack(self, callDefi: Definition, isVisited=True, isEntry=False):\n        \"\"\"ID: dd3cd62b-13f3-4251-8360-789787d7bb96\"\"\"\n        if not callDefi:\n            return\n        callNs = callDefi.get_ns()\n        if callNs in self.callStack:\n            if gol.get_value('precision', False):\n                self.cg.add_edge(self.current_ns, callNs)\n            return\n        gol.add_value('cnt')\n        # # if gol.get_value('cnt') % 10 == 0:\n        # with open(base + \"text.txt\",'a') as f:\n        #     f.write(\"{}:{}\\n\".format(len(self.scope_manager.scopes),len(self.def_manager.defs)))\n\n        if callDefi.get_type() == utils.constants.FUN_DEF:\n            self.cg.add_edge(self.current_ns, callDefi.get_ns())\n        if callDefi.get_type() == utils.constants.CLS_DEF:\n            if not gol.get_value('precision', False):\n                self.cg.add_edge(self.current_ns, callDefi.get_ns())\n            pass\n        if callDefi.get_type() == utils.constants.EXT_DEF:\n            if not gol.get_value('precision', False):\n                self.cg.add_edge(self.current_ns, callDefi.get_ns())\n            pass\n        if callDefi.get_type() == utils.constants.MOD_DEF:\n            if not gol.get_value('precision', False):\n                self.cg.add_edge(self.current_ns, callDefi.get_ns())\n            pass\n        curScope: ScopeItem = self.scope_manager.get_scope(self.current_ns)\n        callScope: ScopeItem = self.scope_manager.get_scope(callNs)\n        if isVisited:\n            if (\n                    callDefi.get_type() == utils.constants.FUN_DEF\n                    and str(callScope) in self.visited_scope\n            ):\n                return\n        self.callStack.append(callDefi.get_ns())\n        gol.add_value(callDefi.get_ns())\n        self.visited_scope.add(str(callScope))\n        node = self.node_manager.get(callNs)\n        if not node:\n            self.callStack.pop()\n            return\n        imp = self.module_manager.get(self.get_module_ns(callNs))\n        self.import_manager.set_current_mod(imp.name, imp.filename)\n        method = None\n        if callDefi.get_type() == utils.constants.ELSE_DEF:\n            method = \"visit_else\"\n        elif callDefi.get_type() == utils.constants.WHILE_DEF:\n            method = \"visit_With\"\n        else:\n            method = \"visit_\" + node.__class__.__name__\n        visitor = getattr(super(), method, self.generic_visit)\n        if callDefi.get_type() == utils.constants.IF_DEF:\n            visitor(node, utils.get_if_name(curScope.get_if_counter()))\n        elif callDefi.get_type() == utils.constants.ELSE_DEF:\n            visitor(node, utils.get_else_name(curScope.get_if_counter()))\n        elif callDefi.get_type() == utils.constants.LAMBDA_NAME:\n            visitor(node, utils.get_lambda_name(curScope.get_if_counter()))\n        elif callDefi.get_type() == utils.constants.LIST_DEF:\n            visitor(node, utils.get_list_name(curScope.get_list_counter()))\n        elif callDefi.get_type() == utils.constants.MAP_DEF:\n            visitor(node, utils.get_dict_name(curScope.get_dict_counter()))\n        else:\n            visitor(node)\n        if isEntry:\n            if hasattr(node, \"lineno\"):\n                self.popStack(node.lineno, isEntry)\n            else:\n                self.popStack()\n        else:\n            self.popStack()\n        pass\n\n    def popStack(self, row=0, isEntry=False):\n        \"\"\"ID: 0499f7a6-bcad-471a-830d-135fe1810d1f\"\"\"\n        callNs: str = self.callStack.pop()\n        callDefi: Definition = self.def_manager.get(callNs)\n        callScope: ScopeItem = self.scope_manager.get_scope(callNs)\n        if callScope:\n            callScope.reset_counters()\n\n        def update_change(change: dict):\n            \"\"\"ID: 99ffac1c-5c09-4fe8-9523-e784c1a04621\"\"\"\n            for key, change in change.items():\n                scopens = self.get_scope_ns(key)\n                if not scopens:\n                    return\n                scope: ScopeItem = self.scope_manager.get_scope(scopens)\n                if not scope:\n                    return\n                field = key[len(scopens) + 1:]\n                defi: Definition = self.def_manager.get(key)\n                if not defi:\n                    defi = self.def_manager.create(\n                        key, utils.constants.NAME_DEF)\n                defi.add_value_point(row, change.get_last_point_value())\n                scope.add_def(field, defi)\n\n        if isEntry:\n            if self.change_manager.getChange(callNs):\n                update_change(self.change_manager.getChange(callNs))\n        if not self.current_ns:\n            return\n        imp = self.module_manager.get(self.get_module_ns(self.current_ns))\n        self.import_manager.set_current_mod(imp.name, imp.filename)\n\n    def visit_Module(self, node):\n        \"\"\"ID: e7fc8d97-dd85-4943-8a35-819fdf37af53\"\"\"\n        def iterate_mod_items(items, const):\n            \"\"\"ID: 86399cfd-2826-4a16-a289-30bf88fccb4f\"\"\"\n            for item in items:\n                defi = self.def_manager.get(item)\n                if not defi:\n                    defi = self.def_manager.create(item, const)\n                splitted = item.split(\".\")\n                name = splitted[-1]\n                parentns = \".\".join(splitted[:-1])\n                self.scope_manager.get_scope(parentns).add_def(name, defi)\n                if const == utils.constants.CLS_DEF:\n                    self.class_manager.create(item, self.modname)\n\n        self.cg.add_node(self.modname, self.modname)\n        self.import_manager.set_current_mod(self.modname, self.filename)\n        mod = self.module_manager.create(self.modname, self.filename)\n        first = 1\n        last = len(self.contents.splitlines())\n        if last == 0:\n            first = 0\n        mod.add_method(self.modname, first, last)\n        root_sc = self.scope_manager.get_scope(self.modname)\n        self.node_manager.add(self.modname, node)\n        defi: Definition = self.def_manager.get(self.modname)\n        if not defi:\n            defi = self.def_manager.create(\n                self.modname, utils.constants.MOD_DEF)\n        else:\n            defi.def_type = utils.constants.MOD_DEF\n        self.node_manager.add(self.modname, node)\n        if not root_sc or root_sc:\n            # initialize module scopes\n            items = self.scope_manager.handle_module(\n                self.modname, self.filename, self.contents\n            )\n            root_sc = self.scope_manager.get_scope(self.modname)\n            root_defi = self.def_manager.get(self.modname)\n            if not root_defi:\n                root_defi = self.def_manager.create(\n                    self.modname, utils.constants.MOD_DEF\n                )\n            root_sc.add_def(self.modname.split(\".\")[-1], root_defi)\n            # create function and class defs and add them to their scope\n            # we do this here, because scope_manager doesn't have an\n            # interface with def_manager, and we want function definitions\n            # to have the correct points_to set\n            iterate_mod_items(items[\"functions\"], utils.constants.FUN_DEF)\n            iterate_mod_items(items[\"classes\"], utils.constants.CLS_DEF)\n            self.pushStack(root_defi)\n        self.modules_analyzed.add(self.filename)\n\n    def visit_ImportFrom(self, node):\n        \"\"\"ID: 58c9550b-915d-45d2-b642-2565f78eae12\"\"\"\n        self.visit_Import(node, prefix=node.module, level=node.level)\n\n    def visit_With(self, node):\n        \"\"\"ID: 6ed537f3-6b8c-43e9-850e-8bfa9835d252\"\"\"\n        current_scope: ScopeItem = self.scope_manager.get_scope(\n            self.current_ns)\n        if_counter = current_scope.inc_while_counter()\n        if_name = utils.get_while_name(if_counter)\n        if_full_ns = utils.join_ns(self.current_ns, if_name)\n        # create a scope for the lambda\n        self.scope_manager.create_scope(if_full_ns, current_scope)\n        if_def = self.def_manager.handle_if_def(\n            self.current_ns, if_name, utils.constants.WHILE_DEF\n        )\n        # add it to the current scope\n        current_scope.add_def(if_name, if_def)\n        for item in node.items:\n            self.visit(item.context_expr)\n            if not item.optional_vars:\n                return\n            self.visit(item.optional_vars)\n            if isinstance(item.context_expr, ast.Call):\n                leftDefi = self.decode_node(item.context_expr.func)\n                self.visit_Call(item.context_expr)\n            else:\n                leftDefi = self.decode_node(item.context_expr)\n            rightNs = self._get_target_ns(item.optional_vars)\n            if rightNs:\n                rightNs = rightNs[0]\n            else:\n                return\n            rightDefi: Definition = self.def_manager.get(rightNs)\n            if not rightDefi:\n                rightDefi = self.def_manager.create(\n                    rightNs, utils.constants.NAME_DEF)\n            if leftDefi:\n                if not leftDefi[0]:\n                    continue\n                function1Ns = utils.join_ns(leftDefi[0].get_ns(), \"__enter__\")\n                function2Ns = utils.join_ns(leftDefi[0].get_ns(), \"__exit__\")\n\n                # function1Defi = self.def_manager.get(function1Ns)\n                # function2Defi = self.def_manager.get(function2Ns)\n                # function1Defi = self.getYPOint(node.lineno,[function1Ns])\n                # function2Defi = self.getYPOint(node.lineno,[function2Ns])\n                # tmp1 = self.find_field(leftDefi[0].get_ns(),\"__enter__\")\n                # tmp2 = self.find_field(leftDefi[0].get_ns(),\"__exit__\")\n                function1Defi = self.find_field(\n                    leftDefi[0].get_ns(), \"__enter__\")\n                function2Defi = self.find_field(\n                    leftDefi[0].get_ns(), \"__exit__\")\n                # print(tmp1.get_ns(),tmp2.get_ns())\n\n                # print(function1Defi,function2Defi)\n                # for d in function1Defi:\n                #     self.pushStack(d, isEntry=True)\n                # for d in function2Defi:\n                #     self.pushStack(d, isEntry=True)\n                self.pushStack(function1Defi, isEntry=True)\n                self.pushStack(function2Defi, isEntry=True)\n                leftPoint = self.getYPOint(\n                    node.lineno, utils.join_ns(\n                        function1Ns, utils.constants.RETURN_NAME)\n                )\n                self.scope_manager.handle_assign(\n                    self.current_ns, rightNs[len(\n                        self.current_ns) + 1:], rightDefi\n                )\n                rightDefi.add_value_point(node.lineno, leftPoint)\n        self.node_manager.add(if_full_ns, node)\n        self.pushStack(if_def)\n        pass\n\n    def visit_Import(self, node, prefix=\"\", level=0):\n        \"\"\"For imports of the form\n    `from something import anything`\nprefix is set to \"something\".\nFor imports of the form\n    `from .relative import anything`\nlevel is set to a number indicating the number\nof parent directories (e.g. in this case level=1)\n\nID: 474708f7-92a5-4548-9d21-25cc17e336d8\"\"\"\n\n        def handle_src_name(name):\n            \"\"\"ID: d24f0c0d-a48a-43f3-b7ac-592904135cbe\"\"\"\n            # Get the module name and prepend prefix if necessary\n            src_name = name\n            if prefix:\n                src_name = prefix + \".\" + src_name\n            return src_name\n\n        def handle_scopes(imp_name, tgt_name, modname):\n            \"\"\"ID: 6a6c3990-1bae-4be1-b14d-bdbad59b6beb\"\"\"\n            def create_def(scope, name):\n                \"\"\"ID: e52308e5-6d6f-4934-8a73-0679158fc978\"\"\"\n                if name not in scope.get_defs():\n                    def_ns = utils.join_ns(scope.get_ns(), name)\n                    defi = self.def_manager.get(def_ns)\n                    if not defi:\n                        defi = self.def_manager.create(\n                            def_ns, utils.constants.NAME_DEF)\n                    current_scope.add_def(name, defi)\n\n            current_scope = self.scope_manager.get_scope(self.current_ns)\n            imported_scope = self.scope_manager.get_scope(modname)\n            if tgt_name == \"*\":\n                if imported_scope:\n                    for name, defi in imported_scope.get_defs().items():\n                        create_def(current_scope, name)\n                        current_scope.get_def(name).add_value_point(\n                            node.lineno, defi.get_ns()\n                        )\n            else:\n                if imported_scope:\n                    defi = imported_scope.get_def(imp_name)\n                    if not defi:\n                        defi = self.def_manager.get(imp_name)\n                    if not defi:\n                        return\n                    if (\n                            modname == tgt_name\n                            and defi.get_type() != utils.constants.MOD_DEF\n                    ):\n                        create_def(current_scope, tgt_name)\n                        current_scope.get_def(tgt_name).add_value_point(\n                            node.lineno, modname\n                        )\n                    else:\n                        create_def(current_scope, tgt_name)\n                        current_scope.get_def(tgt_name).add_value_point(\n                            node.lineno, defi.get_ns()\n                        )\n\n        # \u52a0\u5165ext_def\uff0c\u4f1a\u51fa\u73b0\u6307\u5411\n        def add_external_def(name, target, row=0):\n            \"\"\"ID: d4c23da1-5f0f-4d31-bd30-1bd52a3916cd\"\"\"\n            # add an external def for the name\n            defi = self.def_manager.get(name)\n            if not defi:\n                defi = self.def_manager.create(name, utils.constants.EXT_DEF)\n            scope = self.scope_manager.get_scope(self.current_ns)\n            if target != \"*\":\n                # add a def for the target that points to the name\n                tgt_ns = utils.join_ns(scope.get_ns(), target)\n                tgt_defi: Definition = self.def_manager.get(tgt_ns)\n                if not tgt_defi:\n                    tgt_defi = self.def_manager.create(\n                        tgt_ns, utils.constants.NAME_DEF)\n                # tgt_defi.add_name_point(row).add(defi.get_ns())\n                tgt_defi.add_value_point(row, defi.get_ns())\n                scope.add_def(target, tgt_defi)\n\n        for import_item in node.names:\n            src_name = handle_src_name(import_item.name)\n            tgt_name = import_item.asname if import_item.asname else import_item.name\n            if src_name == \"tldextract\":\n                print()\n            if tgt_name == \"TLDExtract\":\n                print()\n            imported_name = self.import_manager.handle_import(src_name, level)\n            if not imported_name:\n                add_external_def(src_name, tgt_name, node.lineno)\n                continue\n            fname = self.import_manager.get_filepath(imported_name)\n            if not fname:\n                add_external_def(src_name, tgt_name)\n                continue\n            if not self.decy:\n                if self.import_manager.get_mod_dir() not in fname:\n                    add_external_def(src_name, tgt_name)\n                    continue\n            if fname.endswith(\".py\") and not imported_name in self.modules_analyzed:\n                self.analyze_submodule(imported_name)\n            if not gol.get_value('precision', False):\n                self.cg.add_edge(self.current_ns, imported_name)\n            handle_scopes(import_item.name, tgt_name, imported_name)\n\n    def visit_If(self, node):\n        \"\"\"ID: 2cd1eccb-4307-45cc-befc-abf61450a62e\"\"\"\n        def process_if_main():\n            \"\"\"ID: ee7c28dc-4953-4757-bc72-12a444a68227\"\"\"\n            nodeTest: ast.Compare = node.test\n            if not isinstance(nodeTest, ast.Compare):\n                return False\n            if (\n                    isinstance(nodeTest.left, ast.Name)\n                    and nodeTest.left.id == \"__name__\"\n                    and nodeTest.comparators\n                    and isinstance(nodeTest.comparators[0], ast.Constant)\n                    and nodeTest.comparators[0].value == \"__main__\"\n            ):\n                modNs = self.get_module_ns(self.current_ns)\n                if modNs not in self.module_manager.local:\n                    return True\n            return False\n\n        # The name of a lambda is defined by the counter of the current scope\n        current_scope = self.scope_manager.get_scope(self.current_ns)\n        if_counter = current_scope.inc_if_counter()\n        if_name = utils.get_if_name(if_counter)\n        if_full_ns = utils.join_ns(self.current_ns, if_name)\n        # create a scope for the lambda\n        self.scope_manager.create_scope(if_full_ns, current_scope)\n        if_def = self.def_manager.handle_if_def(self.current_ns, if_name)\n        # add it to the current scope\n        current_scope.add_def(if_name, if_def)\n\n        self.visit(node.test)\n        if process_if_main():\n            return\n        self.node_manager.add(if_full_ns, node)\n        # super().visit_If(node, if_name)\n        # \u5982\u679c\u6709orelse\uff0c\u5c31\u8bf4\u660e\u6709else\n        if hasattr(node, \"orelse\") and len(node.orelse) > 0:\n            current_scope = self.scope_manager.get_scope(self.current_ns)\n            if_counter = current_scope.get_if_counter()\n            else_name = utils.get_else_name(if_counter)\n            else_full_ns = utils.join_ns(self.current_ns, else_name)\n            self.scope_manager.create_scope(else_full_ns, current_scope)\n            else_def = self.def_manager.handle_if_def(\n                self.current_ns, else_name, utils.constants.ELSE_DEF\n            )\n            current_scope.add_def(else_name, else_def)\n            self.match[if_full_ns] = else_full_ns\n            self.node_manager.add(else_full_ns, node)\n            self.pushStack(else_def)\n        else:\n            self.match[if_full_ns] = None\n        self.pushStack(if_def)\n        changeList = self.mergeIfElse(\n            if_full_ns, self.match[if_full_ns], node.lineno)\n\n        self.update(self._get_last_line(node), changeList)\n\n    def visit_While(self, node):\n        \"\"\"ID: b68e722a-7fbc-4c09-b4c5-dceb3f744d7f\"\"\"\n        self.visit_If(node)\n        pass\n\n    def visit_Assign(self, node):\n        \"\"\"ID: ddb0b291-098a-49e3-8524-2258f9559815\"\"\"\n        self._visit_assign(node.value, node.targets, node.lineno)\n\n    def _visit_assign(self, value, targets, row=0):\n        \"\"\"ID: e4a15a9d-da3a-440b-afc1-b1c203bf933f\"\"\"\n        # \u5148\u6267\u884c\u53f3\u8fb9\n        self.visit(value)\n        decoded = self.decode_node(value)\n\n        def assign(xList, y):\n            \"\"\"ID: 12af2b2f-64ed-4767-a08b-d9d4f68bb4c5\"\"\"\n            for x in xList:\n                x_defi = None\n                if isinstance(x, str):\n                    x_defi: Definition = self.get_or_create(\n                        self.current_ns,\n                        x[len(self.current_ns) + 1:],\n                        utils.constants.NAME_DEF,\n                    )\n                elif isinstance(x, Definition):\n                    x_defi = x\n                if not x_defi:\n                    return\n                curNsDefi: Definition = self.def_manager.get(self.current_ns)\n                try:\n                    iter(decoded)\n                except TypeError:\n                    return\n                if not y:\n                    y_point = []\n                else:\n                    y_point = self.getYPOint(row, y)\n                if curNsDefi.get_type() not in [\n                    utils.constants.IF_DEF,\n                    utils.constants.WHILE_DEF,\n                    utils.constants.ELSE_DEF,\n                ]:\n                    x_defi.add_value_point(row, y_point)\n                else:\n                    if self.iSDefiInScope(x_defi.get_ns(), self.current_ns):\n                        x_defi.add_value_point(row, y_point)\n                    else:\n                        self.change_manager.addChange(\n                            self.current_ns, x_defi.get_ns(), row, y_point\n                        )\n            pass\n\n        def store(xList, f, y):\n            \"\"\"ID: 5ac15501-7739-465d-ab2a-a8d46fbf1f12\"\"\"\n            curScope: ScopeItem = self.scope_manager.get_scope(self.current_ns)\n            xPointList = self.getYPOint(row, xList)\n            y_point = self.getYPOint(row, y)\n            for x in xPointList:\n                if (\n                        curScope.get_def(x)\n                        and curScope.get_def(x).get_type() == utils.constants.NAME_DEF\n                ):\n                    curScope.get_def(x).add_value_point(row, y_point)\n                else:\n                    self.change_manager.addChange(\n                        self.current_ns, utils.join_ns(x, f), row, y_point\n                    )\n                    defi: Definition = self.def_manager.get(\n                        utils.join_ns(x, f))\n                    if defi:\n                        defi.add_value_point(row, y_point)\n            pass\n\n        def do_assign(decoded, target):\n            \"\"\"ID: ce075edb-58d3-4c12-8ffd-2ef84e23ec4d\"\"\"\n            self.visit(target)\n            try:\n                iter(decoded)\n            except TypeError:\n                return\n            # decoded = list(filter(lambda x: x is not None, decoded))\n            if isinstance(target, ast.Tuple):\n                for pos, elt in enumerate(target.elts):\n                    if not isinstance(decoded, Definition) and pos < len(decoded):\n                        do_assign(decoded[pos], elt)\n            else:\n                if isinstance(target, ast.Name):\n                    curNsDefi: Definition = self.def_manager.get(\n                        self.current_ns)\n                    if curNsDefi.get_type() not in [\n                        utils.constants.IF_DEF,\n                        utils.constants.WHILE_DEF,\n                        utils.constants.ELSE_DEF,\n                    ]:\n                        assign(self._get_target_ns(target), decoded)\n                    else:\n                        leftTarget = self.scope_manager.get_def(\n                            self.current_ns, target.id\n                        )\n                        if not leftTarget:\n                            leftTargetNs = utils.join_ns(\n                                self.current_ns, target.id)\n                            leftTargetDefi = self.def_manager.create(\n                                leftTargetNs, utils.constants.NAME_DEF\n                            )\n                            self.scope_manager.handle_assign(\n                                self.current_ns, target.id, leftTargetDefi\n                            )\n                        assign(self.decode_node(target), decoded)\n                elif isinstance(target, ast.Attribute):\n                    store(self.decode_node(target.value), target.attr, decoded)\n                elif isinstance(target, ast.Subscript):\n                    decoded = self.flatten(decoded)\n                    decoded = list(filter(lambda x: x is not None, decoded))\n                    # leftList = self.getYPOint(target.lineno,self._get_target_ns(target.value))\n                    leftList = self.getYPOint(\n                        target.lineno, self.decode_node(target.value))\n\n                    # left = self.getYPOint(row,self.decode_node(target.value))\n                    for left in leftList:\n                        leftDefi: Definition = self.def_manager.get(left)\n                        if not leftDefi or leftDefi.get_type() not in [utils.constants.LIST_DEF,\n                                                                       utils.constants.MAP_DEF]:\n                            continue\n                        if getattr(target.slice, \"value\", None) is not None and self._is_literal(target.slice.value):\n                            sl_names = [target.slice.value]\n                        else:\n                            # sl_names = self.decode_node(target.slice)\n                            sl_names = self.decode_node(target.value)\n                        keys = set()\n                        for s in sl_names:\n                            if isinstance(s, Definition):\n                                keys.add(s.get_ns())\n                            elif isinstance(s, str):\n                                keys.add(s)\n                            elif isinstance(s, int):\n                                keys.add(s)\n                        for key in keys:\n                            for x in decoded:\n                                if not x:\n                                    print()\n                            leftDefi.set_element(key, list(\n                                map(lambda x: x.get_ns() if isinstance(x, Definition) else x, decoded)))\n\n        for target in targets:\n            do_assign(decoded, target)\n\n    def visit_Lambda(self, node):\n        \"\"\"ID: d9d2f8b9-2b76-4222-a20c-20cd6c3cf4f1\"\"\"\n        # The name of a lambda is defined by the counter of the current scope\n        fn_ns = self._handle_ns()\n        current_scope = self.scope_manager.get_scope(self.current_ns)\n        lambda_counter = current_scope.inc_lambda_counter()\n        lambda_name = utils.get_lambda_name(lambda_counter)\n        lambda_full_ns = utils.join_ns(self.current_ns, lambda_name)\n\n        # create a scope for the lambda\n        self.scope_manager.create_scope(lambda_full_ns, current_scope)\n        lambda_def = self._handle_function_def(node, lambda_name, fn_ns)\n        current_scope.add_def(lambda_name, lambda_def)\n        self.node_manager.add(lambda_full_ns, node)\n\n    def visit_List(self, node):\n        \"\"\"ID: b5ba9615-6cd4-435a-a21f-9fdc5386b213\"\"\"\n        list_counter = self.scope_manager.get_scope(\n            self.current_ns).inc_list_counter()\n        list_name = utils.get_list_name(list_counter)\n        defiNs = utils.join_ns(self.current_ns, list_name)\n        list_defi: Definition = self.def_manager.get(defiNs)\n        if not list_defi:\n            list_defi = self.def_manager.create(\n                defiNs, utils.constants.LIST_DEF)\n            self.scope_manager.handle_assign(\n                self.current_ns, list_name, list_defi)\n            self.node_manager.add(list_defi.get_ns(), node)\n            current_scope: ScopeItem = self.scope_manager.get_scope(\n                self.current_ns)\n            self.scope_manager.create_scope(list_defi.get_ns(), current_scope)\n        else:\n            list_defi.def_type = utils.constants.LIST_DEF\n        self.pushStack(list_defi)\n        for idx, elt in enumerate(node.elts):\n            # self.visit(elt)\n            # tmp = self.decode_node(elt)\n            # key_full_ns = utils.join_ns(list_defi.get_ns(), utils.get_int_name(idx))\n            # key_def:Definition = self.def_manager.get(key_full_ns)\n            # if not key_def:\n            #     key_def = self.def_manager.create(key_full_ns, utils.constants.NAME_DEF)\n            # idx += 1\n            decoded_elt = self.decode_node(elt, utils.get_list_name(idx + 1))\n            decoded_elt = self.getYPOint(node.lineno, decoded_elt)\n            list_defi.set_element(idx, decoded_elt)\n            # key_def.add_value_point(node.lineno,decoded_elt)\n            # for v in decoded_elt:\n            #     if isinstance(v, Definition):\n            #         key_def.add_value_point(node.lineno,[v.get_ns()])\n            #     else:\n            #         key_def.get_lit_pointer().add(v)\n        pass\n\n    def visit_Dict(self, node):\n        \"\"\"ID: de010d1b-2094-44dd-affa-8466e8a43fe5\"\"\"\n        dict_counter = self.scope_manager.get_scope(\n            self.current_ns).inc_dict_counter()\n        dict_name = utils.get_dict_name(dict_counter)\n        defiNs = utils.join_ns(self.current_ns, dict_name)\n        dict_defi: Definition = self.def_manager.get(defiNs)\n        if not dict_defi:\n            dict_defi = self.def_manager.create(\n                defiNs, utils.constants.MAP_DEF)\n            self.scope_manager.handle_assign(\n                self.current_ns, dict_name, dict_defi)\n            self.node_manager.add(dict_defi.get_ns(), node)\n            current_scope: ScopeItem = self.scope_manager.get_scope(\n                self.current_ns)\n            self.scope_manager.create_scope(dict_defi.get_ns(), current_scope)\n        self.pushStack(dict_defi)\n        for key, val in zip(node.keys, node.values):\n            # self.visit(elt)\n            # tmp = self.decode_node(elt)\n            # key_full_ns = utils.join_ns(list_defi.get_ns(), utils.get_int_name(idx))\n            # key_def:Definition = self.def_manager.get(key_full_ns)\n            # if not key_def:\n            #     key_def = self.def_manager.create(key_full_ns, utils.constants.NAME_DEF)\n            decoded_elt = self.decode_node(val, utils.get_dict_name(\n                self.scope_manager.get_scope(self.current_ns).get_dict_counter()))\n            decoded_elt = self.getYPOint(node.lineno, decoded_elt)\n            dict_defi.set_element(key, decoded_elt)\n            # key_def.add_value_point(node.lineno,decoded_elt)\n            # for v in decoded_elt:\n            #     if isinstance(v, Definition):\n            #         key_def.add_value_point(node.lineno,[v.get_ns()])\n            #     else:\n            #         key_def.get_lit_pointer().add(v)\n        pass\n        pass\n\n    def _get_fun_defaults(self, node):\n        \"\"\"ID: afbcc81e-8950-49a6-be26-81c2893dcc3b\"\"\"\n        defaults = {}\n        if node.args.posonlyargs:\n            start = len(node.args.args) - len(node.args.defaults)\n            for cnt, d in enumerate(node.args.defaults, start=start):\n                if not d:\n                    continue\n                self.visit(d)\n                # defaults[node.args.args[cnt].arg] = self.decode_node(d)\n                # print(node.lineno)\n                # print(cnt,node.args.posonlyargs)\n                if cnt >= len(node.args.posonlyargs):\n                    continue\n                defaults[node.args.posonlyargs[cnt].arg] = self.getYPOint(\n                    node.lineno, self.decode_node(d)\n                )\n            return defaults\n        # try:\n        start = len(node.args.args) - len(node.args.defaults)\n\n        for cnt, d in enumerate(node.args.defaults, start=start):\n            if not d:\n                continue\n            self.visit(d)\n            defaults[node.args.args[cnt].arg] = self.getYPOint(\n                node.lineno, self.decode_node(d)\n            )\n        return defaults\n\n    def _handle_function_def(self, node, fn_name, fn_ns):\n        \"\"\"ID: 72b1d325-3f41-4c11-a04e-49c273a92cae\"\"\"\n        currentNsDefi = self.def_manager.get(fn_ns)\n        defaults = self._get_fun_defaults(node)\n        fn_def: Definition = self.def_manager.handle_function_def(\n            fn_ns, fn_name)\n        fn_scope: ScopeItem = self.scope_manager.get_scope(fn_def.get_ns())\n        if not fn_scope:\n            fn_scope = self.scope_manager.create_scope(\n                fn_def.get_ns(), self.scope_manager.get_scope(fn_ns)\n            )\n        ret_def: Definition = self.def_manager.get(\n            utils.join_ns(fn_def.get_ns(), utils.constants.RETURN_NAME)\n        )\n        fn_scope.add_def(utils.constants.RETURN_NAME, ret_def)\n        modNs = self.get_module_ns(self.current_ns)\n        mod = self.module_manager.get(modNs)\n        if not mod:\n            mod = self.module_manager.create(self.modname, self.filename)\n        mod.add_method(fn_def.get_ns(), node.lineno, self._get_last_line(node))\n        defs_to_create = []\n\n        is_static_method = False\n        tmpargs = node.args.args[:]\n        if hasattr(node, \"decorator_list\"):\n            for decorator in node.decorator_list:\n                if (\n                        isinstance(decorator, ast.Name)\n                        and decorator.id == utils.constants.STATIC_METHOD\n                ):\n                    is_static_method = True\n        if (\n                currentNsDefi.get_type() == utils.constants.CLS_DEF\n                and not is_static_method\n                and node.args.args\n        ):\n            arg_ns = utils.join_ns(fn_def.get_ns(), node.args.args[0].arg)\n            arg_def = self.def_manager.get(arg_ns)\n            if not arg_def:\n                arg_def = self.def_manager.create(\n                    arg_ns, utils.constants.PARAM_DEF)\n            arg_def.add_value_point(\n                node.lineno, utils.join_ns(currentNsDefi.get_ns(), \"self\")\n            )\n            self.scope_manager.handle_assign(\n                fn_def.get_ns(), node.args.args[0].arg, arg_def\n            )\n            tmpargs = node.args.args[1:]\n\n        for pos, arg in enumerate(tmpargs):\n            arg_ns = utils.join_ns(fn_def.get_ns(), arg.arg)\n            defs_to_create.append(arg_ns)\n\n        for arg in node.args.kwonlyargs:\n            arg_ns = utils.join_ns(fn_def.get_ns(), arg.arg)\n            defs_to_create.append(arg_ns)\n        for arg_ns in defs_to_create:\n            arg_def = self.def_manager.get(arg_ns)\n            if not arg_def:\n                arg_def: Definition = self.def_manager.create(\n                    arg_ns, utils.constants.PARAM_DEF\n                )\n            self.scope_manager.handle_assign(\n                fn_def.get_ns(), arg_def.get_name(), arg_def\n            )\n            arg_name = arg_ns.split(\".\")[-1]\n            if defaults.get(arg_name, None):\n                arg_def.add_value_point(node.lineno, defaults[arg_name])\n            self.scope_manager.add_params(fn_def.get_ns(), arg_def)\n        return fn_def\n\n    def visit_AsyncFunctionDef(self, node):\n        \"\"\"ID: 26a56774-ffb8-4897-95a9-c9f9cd4fc7b7\"\"\"\n        self.visit_FunctionDef(node)\n\n    def visit_For(self, node):\n        \"\"\"ID: e3cdd6c1-043f-41f8-aa23-6d71fd164853\"\"\"\n        self.visit(node.iter)\n        self.visit(node.target)\n        # if isinstance(node.iter,tuple):\n        if isinstance(node.target, ast.Name):\n            tmpList = self._get_target_ns(node.target)\n            for tmp in tmpList:\n                if not self.def_manager.get(tmp):\n                    tmpDefi = self.def_manager.create(\n                        tmp, utils.constants.NAME_DEF)\n                    self.scope_manager.handle_assign(\n                        self.current_ns, node.target.id, tmpDefi)\n        elif isinstance(node.target, tuple):\n            for x in node.target.elts:\n                if isinstance(x, ast.Name):\n                    tmpList = self._get_target_ns(x)\n                    for tmp in tmpList:\n                        if not self.def_manager.get(tmp):\n                            tmpDefi = self.def_manager.create(\n                                tmp, utils.constants.NAME_DEF)\n                            self.scope_manager.handle_assign(\n                                self.current_ns, x.target.id, tmpDefi)\n        pointList = []\n        inodeList = self.decode_node(node.target)\n        if isinstance(node.iter, ast.Call):\n            iter_decoded = self.decode_node(node.iter.func)\n        elif isinstance(node.iter, ast.Name):\n            iter_decoded = self.decode_node(node.iter)\n        else:\n            iter_decoded = []\n        for item in iter_decoded:\n            if not isinstance(item, Definition):\n                continue\n            names = self.getYPOint(node.lineno, item.get_ns())\n            for name in names:\n                iter_ns = utils.join_ns(name, utils.constants.ITER_METHOD)\n                next_ns = utils.join_ns(name, utils.constants.NEXT_METHOD)\n                return_ns = utils.join_ns(name, utils.constants.RETURN_NAME)\n                iter_return_ns = utils.join_ns(\n                    name, utils.constants.ITER_METHOD, utils.constants.RETURN_NAME)\n                next_return_ns = utils.join_ns(\n                    name, utils.constants.NEXT_METHOD, utils.constants.RETURN_NAME)\n                if self.def_manager.get(iter_ns):\n                    # self.cg.add_edge(self.current_ns, iter_ns)\n                    self.pushStack(self.def_manager.get(iter_ns))\n                if self.def_manager.get(next_ns):\n                    # self.cg.add_edge(self.current_ns, next_ns)\n                    self.pushStack(self.def_manager.get(next_ns))\n                if self.def_manager.get(iter_return_ns):\n                    pointList += self.getYPOint(node.lineno, iter_return_ns)\n                if self.def_manager.get(next_return_ns):\n                    pointList += self.getYPOint(node.lineno, next_return_ns)\n                if self.def_manager.get(return_ns):\n                    pointList += self.getYPOint(node.lineno, return_ns)\n        pointList = list(set(pointList))\n        for inode in inodeList:\n            if isinstance(inode, Definition):\n                inode.add_value_point(node.lineno, pointList)\n        super().visit_For(node)\n\n    def visit_FunctionDef(self, node):\n        \"\"\"ID: d3462867-9ef3-4732-8a3a-ed192a7d01ca\"\"\"\n        curNs = self._handle_ns()\n        fn_def = self._handle_function_def(node, node.name, curNs)\n        curScope: ScopeItem = self.scope_manager.get_scope(curNs)\n        fn_scope: ScopeItem = self.scope_manager.get_scope(fn_def.get_ns())\n        if not self.scope_manager.get_scope(fn_def.get_ns()):\n            fn_scope = self.scope_manager.create_scope(\n                fn_def.get_ns(), curScope)\n        curScope.add_def(node.name, fn_def)\n        self.node_manager.add(fn_def.get_ns(), node)\n\n        if node.decorator_list:\n            reversed_decorators = list(reversed(node.decorator_list))\n            if hasattr(fn_def, \"decorator_names\") and reversed_decorators:\n                last_decoded = self.decode_node(reversed_decorators[-1])\n                for d in last_decoded:\n                    if not isinstance(d, Definition):\n                        continue\n            for index, decorator in enumerate(reversed_decorators):\n                if index == 0:\n                    self.visit_Call(decorator, True, [fn_def])\n                else:\n                    decorate_defi_list = self.getYPOint(\n                        node.lineno, self.decode_node(reversed_decorators[index - 1]))\n                    decorate_return_list = list(\n                        map(lambda x: utils.join_ns(x, utils.constants.RETURN_NAME), decorate_defi_list))\n                    # self.visit_Call(decorator, True, self.decode_node(reversed_decorators[index-1]))\n                    self.visit_Call(decorator, True, decorate_return_list)\n        # self.pushStack(fn_def)\n        # super().visit_FunctionDef(node)\n        pass\n\n    def _get_last_line(self, node):\n        \"\"\"ID: 75603f78-aa89-4102-a3e6-f35198f88d0d\"\"\"\n        lines = sorted(\n            list(ast.walk(node)),\n            key=lambda x: x.lineno if hasattr(x, \"lineno\") else 0,\n            reverse=True,\n        )\n        if not lines:\n            return node.lineno\n        last = getattr(lines[0], \"lineno\", node.lineno)\n        if last < node.lineno:\n            return node.lineno\n        return last\n\n    def visit_ClassDef(self, node):\n        \"\"\"ID: 336be0e5-b19f-41da-a1d9-e9ca99b29d2c\"\"\"\n        cls_ns = self._handle_ns()\n        cls_def: Definition = self.def_manager.handle_class_def(\n            self.current_ns, node.name, cls_ns\n        )\n        cls_scope: ScopeItem = self.scope_manager.get_scope(cls_def.get_ns())\n        if not self.scope_manager.get_scope(cls_def.get_ns()):\n            cls_scope = self.scope_manager.create_scope(\n                cls_def.get_ns(), self.scope_manager.get_scope(cls_ns)\n            )\n        cls: ClassNode = self.class_manager.get(cls_def.get_ns())\n        if not cls:\n            cls: ClassNode = self.class_manager.create(\n                cls_def.get_ns(), self.modname)\n        cls_ret = utils.join_ns(cls_def.get_ns(), utils.constants.RETURN_NAME)\n        cls_ret_defi: Definition = self.def_manager.get(cls_ret)\n        cls_self = utils.join_ns(cls_def.get_ns(), \"self\")\n        cls_self_defi: Definition = self.def_manager.get(cls_self)\n        if not cls_ret_defi:\n            cls_ret_defi = self.def_manager.create(\n                cls_ret, utils.constants.RETURN_DEF)\n        cls_scope.add_def(utils.constants.RETURN_NAME, cls_ret_defi)\n        if not cls_self_defi:\n            cls_self_defi = self.def_manager.create(\n                cls_self, utils.constants.NAME_DEF)\n        cls_scope.add_def(\"self\", cls_self_defi)\n        cls_ret_defi.add_value_point(node.lineno, [cls_def.get_ns()])\n        cls_self_defi.add_value_point(node.lineno, [cls_def.get_ns()])\n\n        curScope: ScopeItem = cls_scope.parent\n        if not curScope:\n            return\n        curScope.add_def(node.name, cls_def)\n        cls.clear_mro()\n        for base in node.bases:\n            # all bases are of the type ast.Name\n            self.visit(base)\n            # bases = self.decode_node(base)\n            bases = self.getYPOint(node.lineno, self.decode_node(base))\n            for base in bases:\n                base_def: Definition = self.def_manager.get(base)\n                if not isinstance(base_def, Definition):\n                    continue\n                names = set()\n                if base_def.points:\n                    names = base_def.get_last_point_value()\n                else:\n                    names.add(base_def.get_ns())\n                for name in names:\n                    # add the base as a parent\n                    cls.add_parent(name)\n                    # add the base's parents\n                    parent_cls = self.class_manager.get(name)\n                    # if parent_cls:\n                    #     cls.add_parent(parent_cls.get_mro())\n        mroList = cls.mro\n        for name in mroList:\n            parent_cls = self.class_manager.get(name)\n            if parent_cls:\n                cls.add_parent(parent_cls.get_mro())\n        cls.compute_mro()\n        self.node_manager.add(cls_def.get_ns(), node)\n        self.pushStack(cls_def)\n        pass\n\n    def decode_node(self, node, index=None):\n        \"\"\"ID: 285fe901-0e94-49e9-ad71-7d04ab3bc23f\"\"\"\n        if isinstance(node, ast.Name):\n            return [self.scope_manager.get_def(self.current_ns, node.id)]\n        elif isinstance(node, ast.Call):\n            decoded = self.decode_node(node.func)\n            return_defs = []\n            for call_def in decoded:\n                if not isinstance(call_def, Definition):\n                    continue\n                calleeNs = utils.join_ns(\n                    call_def.get_ns(), utils.constants.RETURN_NAME)\n                defi = self.def_manager.get(calleeNs)\n                if not defi:\n                    defi = self.def_manager.create(\n                        calleeNs, utils.constants.NA_DEF)\n                return_defs.append(defi)\n            return return_defs\n        elif isinstance(node, ast.Lambda):\n            lambda_counter = self.scope_manager.get_scope(\n                self.current_ns\n            ).get_lambda_counter()\n            lambda_name = utils.get_lambda_name(lambda_counter)\n            return [self.scope_manager.get_def(self.current_ns, lambda_name)]\n        elif isinstance(node, ast.Tuple):\n            decoded = []\n            for elt in node.elts:\n                decoded.append(self.decode_node(elt))\n            return decoded\n        elif isinstance(node, ast.BinOp):\n            decoded_left = self.decode_node(node.left)\n            decoded_right = self.decode_node(node.right)\n            if not isinstance(decoded_left, Definition):\n                return decoded_left\n            if not isinstance(decoded_right, Definition):\n                return decoded_right\n        elif isinstance(node, ast.Attribute):\n            names = self.decode_node(node.value)\n            defis = []\n            for name in names:\n                if not isinstance(name, Definition):\n                    return defis\n                ns = utils.join_ns(name.get_ns(), node.attr)\n                defi = self.def_manager.get(ns)\n                if defi:\n                    defis.append(defi)\n                else:\n                    defi = self.def_manager.create(ns, utils.constants.NA_DEF)\n                    defis.append(defi)\n            return defis\n        elif isinstance(node, ast.Num):\n            # defiNs = utils.join_ns(self.current_ns, '<int>')\n            defiNs = \"<int>\"\n            defi = self.def_manager.get(defiNs)\n            if not defi:\n                defi = self.def_manager.create(defiNs, utils.constants.INT_DEF)\n            return [defi]\n        elif isinstance(node, ast.Str):\n            defiNs = \"<str>\"\n            defi = self.def_manager.get(defiNs)\n            if not defi:\n                defi = self.def_manager.create(defiNs, utils.constants.STR_DEF)\n            return [defi]\n        elif self._is_literal(node):\n            return [node]\n        # elif isinstance(node, ast.Dict):\n        #     if not self.scope_manager.get_scope(self.current_ns):\n        #         return [\"dict\"]\n        #     dict_counter = self.scope_manager.get_scope(\n        #         self.current_ns\n        #     ).get_dict_counter()\n        #     dict_name = utils.get_dict_name(dict_counter)\n        #     defiNs = utils.join_ns(self.current_ns, dict_name)\n        #     defi = self.def_manager.get(defiNs)\n        #     if not defi:\n        #         defi = self.def_manager.create(defiNs, utils.constants.MAP_DEF)\n        #         self.scope_manager.handle_assign(self.current_ns, dict_name, defi)\n        #     scope_def = self.scope_manager.get_def(self.current_ns, dict_name)\n        #     return [self.scope_manager.get_def(self.current_ns, dict_name)]\n        # elif isinstance(node, ast.List):\n        #     list_counter = self.scope_manager.get_scope(\n        #         self.current_ns\n        #     ).get_list_counter()\n        #     list_name = utils.get_list_name(list_counter)\n        #     defiNs = utils.join_ns(self.current_ns, list_name)\n        #     defi = self.def_manager.get(defiNs)\n        #     if not defi:\n        #         defi = self.def_manager.create(defiNs, utils.constants.LIST_DEF)\n        #         self.scope_manager.handle_assign(self.current_ns, list_name, defi)\n        #     return [self.scope_manager.get_def(self.current_ns, list_name)]\n        elif isinstance(node, ast.Dict):\n            if not index:\n                if not self.scope_manager.get_scope(self.current_ns):\n                    return ['dict']\n                dict_counter = self.scope_manager.get_scope(\n                    self.current_ns).get_dict_counter()\n                dict_name = utils.get_dict_name(dict_counter)\n                defiNs = utils.join_ns(self.current_ns, dict_name)\n                defi = self.def_manager.get(defiNs)\n                if not defi:\n                    defi = self.def_manager.create(\n                        defiNs, utils.constants.MAP_DEF)\n                    self.scope_manager.handle_assign(\n                        self.current_ns, dict_name, defi)\n                return [self.scope_manager.get_def(self.current_ns, dict_name)]\n            else:\n                curScope: ScopeItem = self.scope_manager.get_scope(\n                    utils.join_ns(self.current_ns))\n                if not curScope:\n                    return []\n                dict_counter = curScope.get_dict_counter()\n                dict_name = utils.get_dict_name(dict_counter)\n                defiNs = utils.join_ns(self.current_ns, dict_name, index)\n                defi = self.def_manager.get(defiNs)\n                if not defi:\n                    return \"<dict>\"\n                # if not defi:\n                #     defi = self.def_manager.create(defiNs, utils.constants.LIST_DEF)\n                #     self.scope_manager.handle_assign(self.current_ns, list_name, defi)\n                return [defiNs]\n        elif isinstance(node, ast.List):\n            if not index:\n                if not self.scope_manager.get_scope(self.current_ns):\n                    return ['list']\n                list_counter = self.scope_manager.get_scope(\n                    self.current_ns).get_list_counter()\n                list_name = utils.get_list_name(list_counter)\n                defiNs = utils.join_ns(self.current_ns, list_name)\n                defi = self.def_manager.get(defiNs)\n                if not defi:\n                    defi = self.def_manager.create(\n                        defiNs, utils.constants.MAP_DEF)\n                    self.scope_manager.handle_assign(\n                        self.current_ns, list_name, defi)\n                return [self.scope_manager.get_def(self.current_ns, list_name)]\n            else:\n                curScope: ScopeItem = self.scope_manager.get_scope(\n                    utils.join_ns(self.current_ns))\n                if not curScope:\n                    return []\n                list_counter = curScope.get_dict_counter()\n                list_name = utils.get_dict_name(list_counter)\n                defiNs = utils.join_ns(self.current_ns, list_name, index)\n                defi = self.def_manager.get(defiNs)\n                if not defi:\n                    return \"<list>\"\n                # if not defi:\n                #     defi = self.def_manager.create(defiNs, utils.constants.LIST_DEF)\n                #     self.scope_manager.handle_assign(self.current_ns, list_name, defi)\n                return [defiNs]\n        elif isinstance(node, ast.Subscript):\n            names = self.retrieve_subscript_names(node)\n            defis = []\n            for name in names:\n                defi = self.def_manager.get(name)\n                if defi:\n                    defis.append(defi)\n            return defis\n\n        elif isinstance(node, ast.JoinedStr):\n            return [\"<str>\"]\n        return []\n\n    def visit_Call(self, node, decorator=False, decoratorParam=None):\n        \"\"\"ID: 94dc38c3-c3c8-4e86-b5f0-6bc0e1d5a9af\"\"\"\n        def resolve_call():\n            \"\"\"ID: fd9ea3dd-0a19-4a26-9629-43341b7dd127\"\"\"\n            if decorator:\n                if isinstance(node, ast.Name):\n                    self.visit(node)\n                    if getattr(node, \"id\", None) and self.is_builtin(node.id):\n                        name = utils.join_ns(\n                            utils.constants.BUILTIN_NAME, node.id)\n                        defi = self.def_manager.get(name)\n                        if not defi:\n                            self.def_manager.create(\n                                name, utils.constants.FUN_DEF)\n                        return [name]\n                    else:\n                        curDefi: Definition = self.scope_manager.get_def(\n                            self.current_ns, node.id\n                        )\n                        if not curDefi:\n                            return []\n                        # callDefiNsList = self.getPoint(curDefi.get_ns())\n                        callDefiNsList = self.getYPOint(\n                            1000, [curDefi.get_ns()])\n                        return callDefiNsList\n                    pass\n                elif isinstance(node, ast.Attribute):\n                    self.visit(node)\n                    field = node.attr\n                    xDefiList = self.decode_node(node.value)\n                    XPointList = (\n                        self.getYPOint(\n                            node.lineno, xDefiList) if xDefiList else []\n                    )\n                    xFieldList = list(\n                        filter(\n                            lambda x: x,\n                            (map(lambda x: self.find_field(x, field), XPointList)),\n                        )\n                    )\n                    return self.getYPOint(node.lineno, xFieldList)\n                    pass\n                elif isinstance(node, ast.Call):\n                    self.visit(node)\n                    xDefiList = self.decode_node(node)\n                    xRetList = self.getYPOint(node.lineno, xDefiList)\n                    return xRetList\n                elif isinstance(node, ast.Subscript):\n                    # Calls can be performed only on single indices, not ranges\n                    full_names = self.retrieve_subscript_names(node)\n                    return [full_names]\n                return\n            if isinstance(node.func, ast.Name):\n                self.visit(node.func)\n                if getattr(node.func, \"id\", None) and self.is_builtin(node.func.id):\n                    name = utils.join_ns(\n                        utils.constants.BUILTIN_NAME, node.func.id)\n                    defi = self.def_manager.get(name)\n                    if not defi:\n                        self.def_manager.create(name, utils.constants.FUN_DEF)\n                    return [name]\n                else:\n                    curDefi: Definition = self.scope_manager.get_def(\n                        self.current_ns, node.func.id\n                    )\n                    if not curDefi:\n                        return []\n                    # callDefiNsList = self.getPoint(curDefi.get_ns())\n                    callDefiNsList = self.getYPOint(1000, [curDefi.get_ns()])\n                    return callDefiNsList\n                pass\n            elif isinstance(node.func, ast.Attribute):\n                self.visit(node.func)\n                field = node.func.attr\n                xDefiList = self.decode_node(node.func.value)\n                XPointList = self.getYPOint(\n                    node.lineno, xDefiList) if xDefiList else []\n                xFieldList = list(\n                    filter(\n                        lambda x: x,\n                        (map(lambda x: self.find_field(x, field), XPointList)),\n                    )\n                )\n                for XPoint in XPointList:\n                    Xdefi = self.def_manager.get(XPoint)\n                    if isinstance(Xdefi, Definition) and Xdefi.get_type() == utils.constants.MAP_DEF:\n                        if field in ['update']:\n                            for index, param in enumerate(node.args):\n                                if isinstance(param, ast.Dict):\n                                    for index, v in enumerate(param.values):\n                                        decoded = self.decode_node(v)\n                                        values = self.getYPOint(\n                                            node.lineno, decoded)\n                                    # for v in param.values:\n                                    #     values = self.getYPOint(node.lineno,v)\n                                        Xdefi.set_element(index, values)\n                            # XPoint.add_value_point()\n                return self.getYPOint(node.lineno, xFieldList)\n                pass\n            elif isinstance(node.func, ast.Call):\n                self.visit(node.func)\n                xDefiList = self.decode_node(node.func)\n                xRetList = self.getYPOint(node.lineno, xDefiList)\n                return xRetList\n            elif isinstance(node.func, ast.Subscript):\n                # Calls can be performed only on single indices, not ranges\n                full_names = self.retrieve_subscript_names(node.func)\n                # return [full_names]\n                return full_names\n            return [None]\n\n        def format_call(call):\n            \"\"\"ID: 9f0a0e57-4eb5-4d7e-9ccb-13e49644e0ac\"\"\"\n            callDefi: Definition = self.def_manager.get(call)\n            if callDefi and callDefi.get_type() == utils.constants.CLS_DEF:\n                # clsCopyNs = self.new(call,node.lineno)\n                clsInit = utils.join_ns(call, utils.constants.CLS_INIT)\n                clsDefi = self.def_manager.get(clsInit)\n                if clsDefi:\n                    return clsInit\n                else:\n                    return None\n            # if callDefi and callDefi.get_type() == utils.constants.FUN_DEF:\n            #     return call\n            return call\n\n        def match_call(call):\n            \"\"\"ID: 54664d41-3f49-4c9a-8663-00498572c6c8\"\"\"\n            if decorator:\n                callDefi: Definition = self.def_manager.get(call)\n                if not callDefi:\n                    # self.cg.add_edge(self.current_ns, call)\n                    return\n                callScope: ScopeItem = self.scope_manager.get_scope(call)\n                if not callScope:\n                    return\n                moduleNs = self.get_module_ns(callScope.get_ns())\n                method = self.module_manager.get_func_name(\n                    moduleNs, callScope.get_ns())\n                if not method:\n                    line = node.lineno\n                else:\n                    line = method[\"first\"]\n                paramList = callScope.params\n                argList = decoratorParam\n                paramsMap = {}\n                for index, param in enumerate(decoratorParam):\n                    if index >= len(argList):\n                        break\n                    if index >= len(paramList):\n                        break\n                    if isinstance(param, str) or isinstance(param, list):\n                        paramsMap[paramList[index].get_ns()] = param\n                    elif isinstance(param, Definition):\n                        paramsMap[paramList[index].get_ns()] = param.get_ns()\n                    elif isinstance(param, dict):\n                        for k, v in param.items():\n                            if not k:\n                                continue\n                            paramsMap[utils.join_ns(callScope.get_ns(), k)] = v\n                for param, arg in paramsMap.items():\n                    paramDefi: Definition = self.def_manager.get(param)\n                    if (\n                            not paramDefi\n                            or not paramDefi.get_type() == utils.constants.PARAM_DEF\n                    ):\n                        continue\n                    if isinstance(arg, str):\n                        argsPoint = self.getYPOint(node.lineno, [arg])\n                    elif isinstance(arg, list) and arg:\n                        # argsPoint = reduce(lambda x, y: x + y, map(lambda x: self.getPoint(x), arg))\n                        argsPoint = self.getYPOint(node.lineno, [arg])\n                    elif isinstance(arg, ScopeItem):\n                        # argsPoint = self.getPoint(arg.get_ns())\n                        argsPoint = self.getYPOint(node.lineno, [arg])\n                    paramDefi.add_value_point(line, argsPoint)\n\n                return\n            callDefi: Definition = self.def_manager.get(call)\n            if not callDefi:\n                # self.cg.add_edge(self.current_ns,call)\n                return\n            callScope: ScopeItem = self.scope_manager.get_scope(call)\n            argList = self._handle_args(node)\n            if not callScope:\n                return\n            moduleNs = self.get_module_ns(callScope.get_ns())\n            method = self.module_manager.get_func_name(\n                moduleNs, callScope.get_ns())\n            if not method:\n                line = node.lineno\n            else:\n                line = method[\"first\"]\n            paramList = callScope.params\n            paramsMap = {}\n            for index, param in enumerate(argList):\n                if index >= len(argList):\n                    break\n                if isinstance(param, str) or isinstance(param, list):\n                    if index >= len(paramList):\n                        break\n                    paramsMap[paramList[index].get_ns()] = param\n                elif isinstance(param, ScopeItem):\n                    paramsMap[paramList[index].get_ns()] = param\n                elif isinstance(param, dict):\n                    for k, v in param.items():\n                        if not k:\n                            continue\n                        paramsMap[utils.join_ns(callScope.get_ns(), k)] = v\n            for param, arg in paramsMap.items():\n                paramDefi: Definition = self.def_manager.get(param)\n                if (\n                        not paramDefi\n                        or not paramDefi.get_type() == utils.constants.PARAM_DEF\n                ):\n                    continue\n                if isinstance(arg, str):\n                    # argsPoint = self.getYPOint(node.lineno, [arg])\n                    # argsPoint = self.getPoint(arg)\n                    argsPoint = self.getYPOint(node.lineno, [arg])\n                elif isinstance(arg, list) and arg:\n                    # argsPoint = reduce(lambda x, y: x + y, map(lambda x: self.getPoint(x), arg))\n                    argsPoint = self.getYPOint(node.lineno, arg)\n                elif isinstance(arg, ScopeItem):\n                    # argsPoint = self.getPoint(arg.get_ns())\n                    argsPoint = self.getYPOint(node.lineno, [arg])\n                else:\n                    continue\n                paramDefi.add_value_point(line, argsPoint)\n\n        def enter_call(call: str):\n            \"\"\"ID: 6431682b-631d-4f92-8555-bf9bca7fe4e6\"\"\"\n            # self.cg.add_edge(self.current_ns, call)\n            callDefi: Definition = self.def_manager.get(call)\n            if callDefi and callDefi.get_type() != utils.constants.EXT_DEF:\n                self.cg.add_edge(self.current_ns, call)\n            tmp = reduce(\n                lambda x, y: x or y, map(\n                    lambda x: x in call, utils.constants.BUILTTYPE)\n            )\n            if not callDefi and tmp:\n                self.cg.add_edge(self.current_ns, call)\n            self.pushStack(callDefi)\n            pass\n\n        def merge_change(callList):\n            \"\"\"ID: fef56969-c486-42db-a632-0366d50ed01c\"\"\"\n            outPoint = {}\n            for call in callList:\n                callChange: dict = self.change_manager.getChange(call)\n                if not callChange:\n                    continue\n                for key, point in callChange.items():\n                    if key in outPoint:\n                        outPoint[key] = outPoint[key].union(\n                            point.get_last_point_value()\n                        )\n                    if key not in outPoint:\n                        outPoint[key] = point.get_last_point_value()\n            out = {}\n            for key, point in outPoint.items():\n                out[key] = ChangeItem(node.lineno, point)\n            return out\n\n        def update_change(change: dict):\n            \"\"\"ID: 15c4a2ad-7c68-4189-ae07-53c008039503\"\"\"\n            for key, change in change.items():\n                scopens = self.get_scope_ns(key)\n                if not scopens:\n                    return\n                scope: ScopeItem = self.scope_manager.get_scope(scopens)\n                if not scope:\n                    return\n                field = key[len(scopens) + 1:]\n                defi: Definition = self.def_manager.get(key)\n                if not defi:\n                    defi = self.def_manager.create(\n                        key, utils.constants.NAME_DEF)\n                defi.add_value_point(\n                    node.lineno, change.get_last_point_value())\n                scope.add_def(field, defi)\n            pass\n        # def builtin_function(func):\n        #     if func == \"<map>.update\":\n\n        # if hasattr(node, \"func\"):\n        #     self.visit(node.func)\n        callList = resolve_call()\n        callList = filter(lambda x: x, callList)\n        callList = list(filter(lambda x: x, map(format_call, callList)))\n        # list(map(match_call, callList))\n        list(map(match_call, callList))\n        list(map(enter_call, callList))\n        if not callList:\n            if hasattr(node, \"args\"):\n                self._handle_args(node)\n\n        changeDict = merge_change(callList)\n        for key, change in changeDict.items():\n            self.change_manager.addChange(\n                self.current_ns, key, node.lineno, change.get_last_point_value()\n            )\n        update_change(changeDict)\n\n    def _handle_args(self, node):\n        \"\"\"ID: 4005c293-cf9d-47fc-a053-432b57fac9eb\"\"\"\n        params_list = []\n\n        for args_node in node.args:\n            self.visit(args_node)\n            decoded = self.decode_node(args_node)\n            for args_defi in decoded:\n                if isinstance(args_defi, Definition):\n                    params_list.append(args_defi.get_ns())\n                else:\n                    params_list.append(args_defi)\n        for keyword in node.keywords:\n            tmpItem = {}\n            self.visit(keyword.value)\n            decoded = self.decode_node(keyword.value)\n            paramDefiDict = {}\n            for args_defi in decoded:\n                if isinstance(args_defi, Definition):\n                    if keyword not in paramDefiDict:\n                        tmpItem.setdefault(keyword.arg, [args_defi.get_ns()])\n                    else:\n                        tmpItem[keyword].append(args_defi.get_ns())\n                else:\n                    if keyword not in paramDefiDict:\n                        tmpItem.setdefault(keyword.arg, [args_defi])\n                    else:\n                        tmpItem[keyword.arg].append(args_defi)\n            params_list.append(tmpItem)\n        return params_list\n\n    def visit_Return(self, node):\n        \"\"\"ID: 2a08bbbd-f81f-4f23-a9c3-feaebbee2885\"\"\"\n        self._visit_return(node)\n\n    def visit_Yield(self, node):\n        \"\"\"ID: 4874e311-6f62-4f7b-8c4e-130e9c95c2d5\"\"\"\n        self._visit_return(node)\n\n    def visit_Raise(self, node):\n        \"\"\"ID: c0d0fe02-9524-4ee2-b63d-66342a2c0918\"\"\"\n        if not node.exc:\n            return\n        self.visit(node.exc)\n        decoded = self.decode_node(node.exc)\n        for d in decoded:\n            if not isinstance(d, Definition):\n                continue\n            names = self.getYPOint(node.lineno, d.get_ns())\n            for name in names:\n                pointer_def = self.def_manager.get(name)\n                if not pointer_def:\n                    continue\n                if pointer_def.get_type() == utils.constants.CLS_DEF:\n                    init_defi = self.find_cls_fun_ns(\n                        name, utils.constants.CLS_INIT)\n                    if init_defi:\n                        self.pushStack(init_defi)\n                if pointer_def.get_type() == utils.constants.EXT_DEF:\n                    self.cg.add_edge(self.current_ns, name)\n\n    def _visit_return(self, node):\n        \"\"\"ID: 530874ea-ce4b-493d-b5cb-bb1f6ced0583\"\"\"\n        if not node or not node.value:\n            return\n        self.visit(node.value)\n        return_ns = utils.join_ns(self.current_ns, utils.constants.RETURN_NAME)\n        self._handle_assign(\n            return_ns,\n            self.getYPOint(node.lineno, self.decode_node(node.value)),\n            row=node.lineno,\n            defiType=utils.constants.RETURN_DEF,\n        )\n        splitted = return_ns.split(\".\")\n        self.scope_manager.handle_assign(\n            \".\".join(splitted[:-1]\n                     ), splitted[-1], self.def_manager.get(return_ns)\n        )\n\n    def get_modules_analyzed(self):\n        \"\"\"ID: f7e254c2-dfdf-4e76-8ebc-e3fd09192ae7\"\"\"\n        return self.modules_analyzed\n\n    def analyze_submodules(self):\n        \"\"\"ID: cad7c8cb-faf2-4765-8c4b-d3fb888e4bc7\"\"\"\n\n        super().analyze_submodules(\n            ExtProcessor,\n            self.import_manager,\n            self.scope_manager,\n            self.def_manager,\n            self.class_manager,\n            self.module_manager,\n            self.call_manager,\n            self.return_manager,\n            self.cg,\n            self.callStack,\n            self.visited_scope,\n            modules_analyzed=self.get_modules_analyzed(),\n        )\n\n    def analyze_submodule(self, imp):\n        \"\"\"ID: f5bd47e7-13f7-4f6b-a914-3887c6eb75e4\"\"\"\n        super().analyze_submodule(\n            ExtProcessor,\n            imp,\n            self.import_manager,\n            self.scope_manager,\n            self.def_manager,\n            self.class_manager,\n            self.module_manager,\n            self.change_manager,\n            self.node_manager,\n            self.cg,\n            self.callStack,\n            self.visited_scope,\n            modules_analyzed=self.get_modules_analyzed(),\n            decy=self.decy,\n        )\n\n    def visit_Try(self, node):\n        \"\"\"ID: 4801109b-334e-4275-9212-13ab86aefc06\"\"\"\n        for item in node.body:\n            self.visit(item)\n        for handler in node.handlers:\n            self.visit(handler)\n        pass\n\n    def visit_ExceptHandler(self, node):\n        \"\"\"ID: 009c9aae-15f1-40bd-92e7-0ce154441c5c\"\"\"\n        for item in node.body:\n            self.visit(item)\n        pass\n\n    def analyze(self):\n        \"\"\"ID: ab485f07-5439-462f-9bea-39e656df3797\"\"\"\n        if not self.filename:\n            return\n        if not self.import_manager.get_node(self.modname):\n            self.import_manager.create_node(self.modname)\n            self.import_manager.set_filepath(self.modname, self.filename)\n\n        try:\n            self.visit(ast.parse(self.contents, self.filename))\n        except Exception:\n            pass\n        # self.visit(ast.parse(self.contents, self.filename))\n\n    def analyze_localfunction(self, localList):\n        \"\"\"ID: 0c53d958-ec06-4dc8-8d3e-4b5f8409fabf\"\"\"\n        for local in localList:\n            localDefi: Definition = self.def_manager.get(local)\n            self.pushStack(localDefi, False, True)\n\n    def analyze_allfunction(self):\n        \"\"\"ID: 52275115-f030-42c1-93a9-2c04fcdbec95\"\"\"\n        def analyze_local(local):\n            \"\"\"ID: c8631869-6856-43ce-8659-ae00e5aaa245\"\"\"\n            moduleNode: Module = self.module_manager.get(local)\n            if not moduleNode:\n                return\n            methodDict: dict = moduleNode.get_methods()\n            for method in list(methodDict.keys()):\n                methodDefi = self.def_manager.get(method)\n                self.pushStack(methodDefi, False, True)\n\n        prev = None\n\n        def equal(prev):\n            \"\"\"ID: 40a489de-98ff-43b0-97a2-9d8c7c793d1a\"\"\"\n            if not prev:\n                return False\n            if set(prev.keys()) == set(\n                    self.module_manager.get_internal_modules().copy()\n            ):\n                return True\n            return False\n\n        cnt = 0\n        while not equal(prev):\n            print(\"iteration\", cnt)\n            cnt += 1\n            prev = self.module_manager.get_internal_modules().copy()\n            for local in self.module_manager.get_internal_modules().copy():\n                analyze_local(local)\n        pass\n\n    def is_builtin(self, name):\n        \"\"\"ID: 8a0c699c-a887-4898-879c-c1b1d77c7ee4\"\"\"\n        return name in __builtins__\n\n    def _get_target_ns(self, target):\n        \"\"\"ID: bc060745-6845-419f-a6f4-220161c09bda\"\"\"\n        if isinstance(target, ast.Name):\n            id = target.id\n            return [utils.join_ns(self.current_ns, id)]\n        if isinstance(target, ast.Attribute):\n            bases = self._get_target_ns(target.value)\n            res = []\n            for base in bases:\n                if not base:\n                    continue\n                res.append(utils.join_ns(base.get_ns(), target.attr))\n            return res\n        if isinstance(target, ast.Subscript):\n            return self.retrieve_subscript_names(target)\n        return []\n\n    def get_or_create(self, ns, x, def_type):\n        \"\"\"ID: 29347aca-3658-4977-8f52-6eab314e4bd8\"\"\"\n        defi = self.def_manager.get(utils.join_ns(ns, x))\n        if not defi:\n            defi = self.def_manager.getOrCreate(utils.join_ns(ns, x), def_type)\n        nsScope: ScopeItem = self.scope_manager.get_scope(ns)\n        if not nsScope:\n            return None\n        nsScope.add_def(x, defi)\n        return defi\n\n    def _handle_ns(self):\n        \"\"\"ID: eb2e2ce6-8d6a-4684-aa66-c0cc898992f7\"\"\"\n        tmpStack = self.callStack[:]\n        curNsDefi: Definition = self.def_manager.get(tmpStack[-1])\n        while curNsDefi.get_type() in [\n            utils.constants.IF_DEF,\n            utils.constants.ELSE_DEF,\n            utils.constants.WHILE_DEF,\n        ]:\n            tmpStack.pop()\n            curNsDefi = self.def_manager.get(tmpStack[-1])\n        finalNs = curNsDefi.get_ns()\n        return finalNs\n\n    def mergeIfElse(self, ifFullNs, elseFullNs, row):\n        \"\"\"ID: 079d27a4-76fb-4727-b1ba-e5d202c86c2e\"\"\"\n        ifChange, elseChange = self.change_manager.getChange(\n            ifFullNs\n        ), self.change_manager.getChange(elseFullNs)\n        returnChangeItem = {}\n        if not ifChange and not elseChange:\n            pass\n        elif not elseChange and ifChange:\n            for defi, item in ifChange.items():\n                returnChangeItem[defi] = ChangeItem(\n                    row, item.get_last_point_value())\n                pass\n        elif not ifChange and elseChange:\n            for defi, item in elseChange.items():\n                returnChangeItem[defi] = ChangeItem(\n                    row, item.get_last_point_value())\n        else:\n            keys = ifChange.keys() | elseChange.keys()\n            for key in keys:\n                if key in ifChange and key in elseChange:\n                    ifChangeItem: ChangeItem = ifChange[key]\n                    elseChangeItem: ChangeItem = elseChange[key]\n                    tmpChangeItem = ChangeItem(\n                        row,\n                        ifChangeItem.get_last_point_value()\n                        | elseChangeItem.get_last_point_value(),\n                    )\n                    returnChangeItem[key] = tmpChangeItem\n                elif key in ifChange:\n                    tmpChangeItem = ChangeItem(\n                        row, ifChange[key].get_last_point_value(), True\n                    )\n                    returnChangeItem[key] = tmpChangeItem\n                else:\n                    tmpChangeItem = ChangeItem(\n                        row, elseChange[key].get_last_point_value(), True\n                    )\n                    returnChangeItem[key] = tmpChangeItem\n        ifScope: ScopeItem = self.scope_manager.get_scope(ifFullNs)\n        elseScope: ScopeItem = self.scope_manager.get_scope(elseFullNs)\n        if ifScope and not elseScope:\n            for defi in ifScope.get_defs():\n                changeNs = utils.join_ns(self.current_ns, defi)\n                changePoint = ifScope.get_def(defi).get_last_point_value()\n                returnChangeItem[changeNs] = ChangeItem(row, changePoint)\n        elif elseScope and not ifScope:\n            for defi in elseScope.get_defs():\n                changeNs = utils.join_ns(self.current_ns, defi)\n                changePoint = elseScope.get_def(defi).get_last_point_value()\n                returnChangeItem[changeNs] = ChangeItem(row, changePoint)\n        elif elseScope and ifScope:\n            keys = ifScope.get_defs().keys() | elseScope.get_defs().keys()\n            for key in keys:\n                tmpKey = utils.join_ns(self.current_ns, key)\n                if key in ifScope.get_defs() and key in elseScope.get_defs():\n                    returnChangeItem[tmpKey] = ChangeItem(\n                        row,\n                        ifScope.get_def(key).get_last_point_value()\n                        | elseScope.get_def(key).get_last_point_value(),\n                    )\n                elif key in ifScope.get_defs():\n                    returnChangeItem[tmpKey] = ChangeItem(\n                        row, ifScope.get_def(key).get_last_point_value()\n                    )\n                elif key in elseScope.get_defs():\n                    returnChangeItem[tmpKey] = ChangeItem(\n                        row, elseScope.get_def(key).get_last_point_value()\n                    )\n        return returnChangeItem\n\n    def update(self, row, changeList: dict):\n        \"\"\"ID: 61569f36-79fd-4cb4-be60-ac5693a1c7f6\"\"\"\n        curNsDefi: Definition = self.def_manager.get(self.current_ns)\n        if curNsDefi.get_type() not in [\n            utils.constants.IF_DEF,\n            utils.constants.WHILE_DEF,\n            utils.constants.ELSE_DEF,\n        ]:\n            for changedDefiNs, change in changeList.items():\n                changedDefi: Definition = self.def_manager.get(changedDefiNs)\n                if not changedDefi:\n                    changedDefi = self.def_manager.create(\n                        changedDefiNs, utils.constants.NAME_DEF\n                    )\n                changedDefi.add_value_point(row, change.get_last_point_value())\n                curScopeNs = self.get_scope_ns(changedDefiNs)\n                curScope: ScopeItem = self.scope_manager.get_scope(curScopeNs)\n                if curScope:\n                    curScope.add_def(\n                        changedDefiNs[len(curScopeNs) + 1:], changedDefi)\n            return\n        curChange: dict = self.change_manager.getChange(self.current_ns)\n        for defiNs, changePoint in changeList.items():\n            if defiNs in curChange:\n                if changePoint.if_union:\n                    curChange[defiNs].addPoint(\n                        row,\n                        changePoint.get_last_point_value()\n                        | changePoint.get_last_point_value(),\n                    )\n                else:\n                    curChange[defiNs].addPoint(\n                        row, changePoint.get_last_point_value())\n            else:\n                curChange[defiNs] = ChangeItem(\n                    row, changePoint.get_last_point_value())\n            changedDefi: Definition = self.def_manager.get(defiNs)\n            if not changedDefi:\n                changedDefi = self.def_manager.create(\n                    defiNs, utils.constants.NAME_DEF)\n            changedDefi.add_value_point(\n                row, changePoint.get_last_point_value())\n            curScopeNs = self.get_scope_ns(defiNs)\n            curScope: ScopeItem = self.scope_manager.get_scope(curScopeNs)\n            if curScope:\n                curScope.add_def(defiNs[len(curScopeNs) + 1:], changedDefi)\n\n    def resolve(self, calleeNs: str, row: int, flag=False) -> list:\n        \"\"\"ID: 534018d5-68cb-4d4c-9387-5f0bb414994d\"\"\"\n        if \"__iter__.<return>\" in calleeNs:\n            print()\n        calleeDefi: Definition = self.def_manager.get(calleeNs)\n        tmp = reduce(\n            lambda x, y: x or y, map(\n                lambda x: x in calleeNs, utils.constants.BUILTTYPE)\n        )\n        if not calleeDefi and tmp:\n            return [calleeNs]\n        if not calleeDefi:\n            return [calleeNs]\n        if not calleeDefi or calleeDefi.get_type() in [\n            utils.constants.NAME_DEF,\n            utils.constants.NA_DEF,\n            utils.constants.PARAM_DEF,\n            utils.constants.RETURN_DEF,\n        ]:\n            nsList = self.get_point(calleeNs, row)\n            return list(set(nsList))\n        if not calleeDefi:\n            return []\n        if calleeDefi.get_type() in [utils.constants.FUN_DEF, utils.constants.EXT_DEF]:\n            return [calleeNs]\n        if calleeDefi.get_type() == utils.constants.CLS_DEF:\n            return (\n                [utils.join_ns(calleeNs, utils.constants.CLS_INIT)]\n                if flag\n                else [calleeNs]\n            )\n        elif calleeDefi.get_type() == utils.constants.INT_DEF:\n            return [\"<int>\"]\n        elif calleeDefi.get_type() == utils.constants.STR_DEF:\n            return [\"<str>\"]\n        elif calleeDefi.get_type() == utils.constants.LIST_DEF:\n            # return [\"<list>\"]\n            return [calleeNs]\n        elif calleeDefi.get_type() == utils.constants.MAP_DEF:\n            return [calleeNs]\n            return [\"<map>\"]\n        else:\n            return [calleeNs]\n\n    def get_point(self, ns, row=0):\n        \"\"\"ID: ebaebdf6-5d25-4d0e-8164-4a279d238e5d\"\"\"\n        def helper(ns: str):\n            \"\"\"ID: c0bacd5e-f5c2-48be-9d6a-4a0c038b16b5\"\"\"\n            rightList = []\n            defi: Definition = self.def_manager.get(ns)\n            while not defi or defi.get_type() in [\n                utils.constants.NA_DEF,\n                utils.constants.PARAM_DEF,\n                utils.constants.RETURN_DEF,\n            ]:\n                rIndex = ns.rfind(\".\")\n                if rIndex == -1:\n                    break\n                rightList.insert(0, ns[rIndex:])\n                ns = ns[:rIndex]\n                defi = self.def_manager.get(ns)\n            rIndex = ns.rfind(\".\")\n            if rIndex != -1:\n                rightList.insert(0, ns[rIndex:])\n                ns = ns[:rIndex]\n            return [ns], rightList\n        if \"__iter__.<RETURN>\" in ns:\n            print()\n        if not isinstance(ns, str):\n            return []\n        leftList, rightList = helper(ns)\n        while rightList:\n            leftList = list(\n                map(lambda x: self.mergeLeftRight(\n                    x, row, rightList[0]), leftList)\n            )\n            rightList.remove(rightList[0])\n            leftList = self.flatten(list(map(self.convert, leftList)))\n        if not leftList:\n            return leftList\n        leftList = list(\n            filter(lambda x: x, self.flatten(\n                list(map(self.convert_final, leftList))))\n        )\n        for x in leftList:\n            if \"__iter__.<RETURN>\" in x:\n                print()\n        return leftList\n\n    def mergeLeftRight(self, left, row, right):\n        \"\"\"ID: d281528c-1135-4bc7-9f20-5e1b3c314e6f\"\"\"\n        if left in [\"<map>\", \"<int>\", \"<str>\", \"<list>\"]:\n            return left\n        right = right[1:]\n        leftScope: ScopeItem = self.scope_manager.get_scope(left)\n        if leftScope:\n            if self.find_field(left, right):\n                return self.find_field(left, right).get_ns()\n        ns = utils.join_ns(left, right)\n        defi = self.def_manager.get(ns)\n        if defi:\n            return defi.get_ns()\n        return ns\n\n    def convert(self, curStr):\n        \"\"\"ID: dff92d16-debf-4e9f-b9bd-66b2db6c5d49\"\"\"\n        def dfs(curStr: str):\n            \"\"\"ID: 097db680-c3d9-4ee1-b1e2-c7d133cdfd2e\"\"\"\n            queue = [curStr]\n            visited = set()\n            while queue:\n                cur = queue[0]\n                queue.remove(cur)\n                if cur in [\"<map>\", \"<int>\", \"<str>\", \"<list>\"]:\n                    visited.add(cur)\n                    continue\n                curDefi: Definition = self.def_manager.get(cur)\n                if not curDefi:\n                    visited.add(cur)\n                    continue\n                if curDefi.get_type() in [\n                    utils.constants.NAME_DEF,\n                    utils.constants.NA_DEF,\n                    utils.constants.PARAM_DEF,\n                    utils.constants.RETURN_DEF,\n                ]:\n                    PointValueList = curDefi.get_last_point_value()\n                    visited = visited.union(set(PointValueList))\n                    for pointValue in PointValueList:\n                        if pointValue not in visited:\n                            queue.append(pointValue)\n                    continue\n                if curDefi.get_type() == utils.constants.INT_DEF:\n                    visited.add(\"<int>\")\n                if curDefi.get_type() == utils.constants.STR_DEF:\n                    visited.add(\"<str>\")\n                if curDefi.get_type() == utils.constants.LIST_DEF:\n                    visited.add(\"<list>\")\n                if curDefi.get_type() == utils.constants.MAP_DEF:\n                    visited.add(\"<map>\")\n                if \"<str>\" in curDefi.get_ns():\n                    visited.add(\"<str>\")\n                if \"<list>\" in curDefi.get_ns():\n                    visited.add(\"<list>\")\n                if \"<dict>\" in curDefi.get_ns():\n                    visited.add(\"<dict>\")\n                if \"<int>\" in curDefi.get_ns():\n                    visited.add(\"<int>\")\n                visited.add(cur)\n            return visited\n\n        if curStr in [\"<map>\", \"<int>\", \"<str>\", \"<list>\"]:\n            return [curStr]\n        curDefi: Definition = self.def_manager.get(curStr)\n        if not curDefi and curStr in self.change_manager.getChange(self.current_ns):\n            changedItem: ChangeItem = self.change_manager.getChange(self.current_ns)[\n                curStr\n            ]\n            res = []\n            pointValueList = changedItem.get_last_point_value()\n            for point in pointValueList:\n                if point in res:\n                    continue\n                # res += self.convert(point)\n                res += dfs(point)\n            return list(set(res))\n        if not curDefi:\n            return [curStr]\n        if curDefi.get_type() in [\n            utils.constants.NAME_DEF,\n            utils.constants.NA_DEF,\n            utils.constants.PARAM_DEF,\n            utils.constants.RETURN_DEF,\n        ]:\n            curDefiList = curDefi.get_last_point_value()\n            if curStr in self.change_manager.getChange(self.current_ns):\n                curDefiList = (\n                    curDefiList\n                    | self.change_manager.getChange(self.current_ns)[\n                        curStr\n                    ].get_last_point_value()\n                )\n            nsList = []\n            for curDefiNs in curDefiList:\n                # tmpList = self.convert(curDefiNs)\n                tmpList = dfs(curDefiNs)\n                for tmp in tmpList:\n                    if tmp in nsList:\n                        continue\n                    else:\n                        nsList.append(tmp)\n                nsList = list(set(nsList))\n            return nsList\n        if curDefi.get_type() == utils.constants.INT_DEF:\n            return [\"<int>\"]\n        if curDefi.get_type() == utils.constants.STR_DEF:\n            return [\"<str>\"]\n        if curDefi.get_type() == utils.constants.LIST_DEF:\n            return [\"<list>\"]\n        if curDefi.get_type() == utils.constants.MAP_DEF:\n            return [\"<map>\"]\n        return [curStr]\n\n    def convert_final(self, curStr):\n        \"\"\"ID: 221e9866-b91a-4bc0-ba03-b7c972581c37\"\"\"\n        curDefi: Definition = self.def_manager.get(curStr)\n        tmp = reduce(\n            lambda x, y: x or y, map(\n                lambda x: x in curStr, utils.constants.BUILTTYPE)\n        )\n        if not curDefi and tmp:\n            return curStr\n        if not curDefi:\n            return None\n        if curDefi.get_type() in [\n            utils.constants.NAME_DEF,\n            utils.constants.PARAM_DEF,\n            utils.constants.RETURN_DEF,\n        ]:\n            curDefiList = curDefi.get_last_point_value()\n            nsList = []\n            for curDefiNs in curDefiList:\n                if curStr == curDefiNs:\n                    continue\n                nsList.append(curDefiNs)\n            return nsList\n        if curDefi.get_type() == utils.constants.INT_DEF:\n            return \"<int>\"\n        if curDefi.get_type() == utils.constants.STR_DEF:\n            return \"<str>\"\n        if curDefi.get_type() == utils.constants.LIST_DEF:\n            return curStr\n            return \"<list>\"\n        if curDefi.get_type() == utils.constants.MAP_DEF:\n            return curStr\n            return \"<map>\"\n        if curDefi.get_type() == utils.constants.NA_DEF:\n            return None\n        return curStr\n\n    def get_module_ns(self, ns):\n        \"\"\"ID: dc1a7557-d329-4c4c-962f-1064a526e539\"\"\"\n        defi: Definition = self.def_manager.get(ns)\n        while not defi or defi.get_type() != utils.constants.MOD_DEF:\n            ns = ns[: ns.rfind(\".\")]\n            if not ns:\n                break\n            defi = self.def_manager.get(ns)\n        return ns\n\n    def get_scope_ns(self, ns):\n        \"\"\"ID: c24ce738-20e4-4570-af3c-74bfb4989d4f\"\"\"\n        while ns and not ns in self.scope_manager.get_scopes():\n            ns = ns[: ns.rfind(\".\")]\n        return ns if ns else None\n\n    def find_field(self, scopeNs, field):\n        \"\"\"ID: e6240ef3-f91b-4675-af03-ee5559a65bd2\"\"\"\n        if scopeNs in [\"<str>\", \"<list>\", \"<map>\", \"<int>\"]:\n            if scopeNs == \"<str>\":\n                if hasattr(str, field):\n                    return utils.join_ns(scopeNs, field)\n            if scopeNs == \"<list>\":\n                if hasattr(list, field):\n                    return utils.join_ns(scopeNs, field)\n            if scopeNs == \"<map>\":\n                if hasattr(dict, field):\n                    return utils.join_ns(scopeNs, field)\n            if scopeNs == \"<int>\":\n                if hasattr(int, field):\n                    return utils.join_ns(scopeNs, field)\n            return None\n            # return utils.join_ns(scopeNs,field)\n        scope: ScopeItem = self.scope_manager.get_scope(scopeNs)\n        scopeDefi: Definition = self.def_manager.get(scopeNs)\n        if not scope and scopeDefi == utils.constants.EXT_DEF:\n            return utils.join_ns(scopeNs, field)\n        defi: Definition = self.def_manager.get(scopeNs)\n        if not scope:\n            return None\n        if not defi:\n            return None\n        if defi.get_type() == utils.constants.CLS_DEF:\n            return self.find_cls_fun_ns(scopeNs, field)\n        return scope.get_def(field)\n\n    def find_cls_fun_ns(self, clsNs, fn):\n        \"\"\"ID: f14477c8-26c9-4679-b6f9-988b5db7246a\"\"\"\n        clsNode: ClassNode = self.class_manager.get(clsNs)\n        for tmpClsNs in clsNode.mro:\n            tmpScope: ScopeItem = self.scope_manager.get_scope(tmpClsNs)\n            if not tmpScope:\n                continue\n            if tmpScope.get_def(fn):\n                selfDefi: Definition = tmpScope.get_def(\"self\")\n                if not selfDefi:\n                    continue\n                selfDefi.add_value_point(0, clsNs)\n                return tmpScope.get_def(fn)\n        return None\n        pass\n\n    def iSDefiInScope(self, defins: Definition, scopens: ScopeItem):\n        \"\"\"ID: 16ebb579-e424-4a60-86c4-39a096a44683\"\"\"\n        defi = self.def_manager.get(defins)\n        scope = self.scope_manager.get_scope(scopens)\n        for name, scopeDefi in scope.get_defs().items():\n            if defi == scopeDefi:\n                return True\n        return False\n\n    def retrieve_subscript_names(self, node, literFlag=False):\n        \"\"\"ID: 926d06ba-e183-4038-b42e-53d7f16578d3\"\"\"\n        if not isinstance(node, ast.Subscript):\n            raise Exception(\"The node is not an subcript\")\n        if getattr(node.slice, \"value\", None) is not None and self._is_literal(node.slice.value):\n            sl_names = [node.slice.value]\n        else:\n            sl_names = self.decode_node(node.slice)\n\n        val_names = self.decode_node(node.value)\n\n        decoded_vals = set()\n        keys = set()\n        full_names = set()\n        # get all names associated with this variable name\n        for n in val_names:\n            if n and isinstance(n, Definition):\n                # decoded_vals |= self.closured.get(n.get_ns())\n                decoded_vals.add(n.get_ns())\n        for s in sl_names:\n            if isinstance(s, Definition):\n                keys.add(s.get_ns())\n            elif isinstance(s, str):\n                keys.add(s)\n            elif isinstance(s, int):\n                keys.add(s)\n        returnDefins = set()\n        for d in decoded_vals:\n            definsList = self.resolveList(d, node.lineno)\n            for defins in definsList:\n                defi: Definition = self.def_manager.get(defins)\n                if defi and defi.get_type() in [utils.constants.LIST_DEF, utils.constants.MAP_DEF]:\n                    if hasattr(defi, 'memo'):\n                        defiList = set(\n                            reduce(lambda x, y: x + y, defi.memo.values()))\n\n                        # defiList = set(map(lambda x:self.resolveList(x,node.lineno),defiList))\n                        returnDefins = returnDefins.union(defiList)\n                elif defi:\n                    returnDefins.add(defins)\n            # for key in keys:\n            #     # check for existence of var name and key combination\n            #     definsList = self.resolve(d,node.lineno)\n            #     for defins in definsList:\n            #         defi:Definition = self.def_manager.get(defins)\n            #         if defi and defi.get_type() == utils.constants.LIST_DEF:\n            #             # defi:Definition = self.def_manager.get(defins)\n            #             # if not defi:\n            #             #     continue\n            #             defiList = defi.get_element(key)\n            #             # defiList = set(map(lambda x:self.resolveList(x,node.lineno),defiList))\n            #             returnDefins = returnDefins.union(set(defiList))\n\n        return returnDefins\n\n    def resolveList(self, calleeNs: str, row: int, flag=False) -> list:\n        \"\"\"ID: f309a7cc-8159-447f-b7bd-80e02a9b6e54\"\"\"\n        calleeDefi: Definition = self.def_manager.get(calleeNs)\n        if not calleeDefi:\n            return []\n        if not calleeDefi or calleeDefi.get_type() in [utils.constants.NAME_DEF, utils.constants.NA_DEF,\n                                                       utils.constants.PARAM_DEF, utils.constants.RETURN_DEF]:\n            # nsList = self.get_point(calleeNs, row)\n            # get_last_point_value\n            nsList = calleeDefi.get_last_point_value()\n            if not nsList:\n                return []\n            return reduce(lambda x, y: x + y, map(lambda x: self.resolveList(x, row), nsList))\n        # elif calleeDefi.get_type() == utils.constants.LIST_DEF:\n        #     # memoDict = getattr(calleeDefi,'memo',{})\n        #     # pointList = list(reduce(lambda x, y: x + y, memoDict.values()))\n        #     # pointList = list(reduce(lambda x, y: x + y, calleeDefi.memo.values()))\n        #     # return reduce(lambda x, y: x or y, map(lambda x: self.resolveList(x, row), pointList))\n        #     # return ['<list>']\n        # elif calleeDefi.get_type() == utils.constants.MAP_DEF:\n        #     # pointList = list(reduce(lambda x, y: x + y, calleeDefi.memo.values()))\n        #     # return reduce(lambda x, y: x or y, map(lambda x: self.resolveList(x, row), pointList))\n        #     # return ['<map>']\n        else:\n            return [calleeNs]\n"
}