{
  "id": "nodes/a56943be-74cf-4ad2-a73d-032cae0c7507",
  "name": "Fasten",
  "node_type": "class",
  "qname": "Jarvis.formats.fasten.Fasten",
  "file_path": "/Users/yared/Documents/Programing/personal/pythonJaRvis.github.io/Jarvis/tool/Jarvis/formats/fasten.py",
  "file_name": "fasten",
  "code": "class Fasten(BaseFormatter):\n    \"\"\"ID: a56943be-74cf-4ad2-a73d-032cae0c7507\"\"\"\n    def __init__(self, cg_generator, package, product, forge, version, timestamp):\n        \"\"\"ID: 973db2b0-b0f5-42f5-8734-9bad755944ae\"\"\"\n        self.cg_generator = cg_generator\n        self.internal_mods = self.cg_generator.output_internal_mods() or {}\n        self.external_mods = self.cg_generator.output_external_mods() or {}\n        self.classes = self.cg_generator.output_classes() or {}\n        self.edges = self.cg_generator.output_edges() or []\n        self.functions = self.cg_generator.output_functions() or []\n        self.unique = 0\n        self.namespace_map = {}\n        self.package = package\n        self.product = product\n        self.forge = forge\n        self.version = version\n        self.timestamp = timestamp\n\n    def get_unique_and_increment(self):\n        \"\"\"ID: 29f150ce-d0de-4c91-a96a-36fbfec15b10\"\"\"\n        unique = self.unique\n        self.unique += 1\n        return unique\n\n    def to_uri(self, modname, name=\"\"):\n        \"\"\"ID: 7a6ae3d5-1141-4ad5-b5f2-0f6d0aef2451\"\"\"\n        cleared = name\n        if name:\n            if name == modname:\n                cleared = \"\"\n            else:\n                if not name.startswith(modname + \".\"):\n                    raise Exception(\"name should start with modname\", name, modname)\n\n                cleared = name[len(modname) + 1 :]\n\n        suffix = \"\"\n        if name in self.functions:\n            suffix = \"()\"\n\n        return \"/{}/{}{}\".format(modname.replace(\"-\", \"_\"), cleared, suffix)\n\n    def to_external_uri(self, modname, name=\"\"):\n        \"\"\"ID: b4dd2dd9-a66a-4d3e-91e7-f0cc43222dd9\"\"\"\n        if modname == utils.constants.BUILTIN_NAME:\n            name = name[len(modname) + 1 :]\n            modname = \".builtin\"\n\n        return \"//{}//{}\".format(modname.replace(\"-\", \"_\"), name)\n\n    def find_dependencies(self, package_path):\n        \"\"\"ID: 48886d8a-079b-47bd-94b9-645830fcd748\"\"\"\n        res = []\n        if not package_path:\n            return res\n        requirements_path = os.path.join(package_path, \"requirements.txt\")\n\n        if not os.path.exists(requirements_path):\n            return res\n\n        reqs = []\n        with open(requirements_path, \"r\") as f:\n            lines = [l.strip() for l in f.readlines()]\n\n        for line in lines:\n            if not line:\n                continue\n\n            req = Requirement.parse(line)\n\n            product = req.unsafe_name\n            specs = req.specs\n\n            constraints = []\n\n            def add_range(begin, end):\n                \"\"\"ID: 735bd0b2-9158-4a62-a018-278ab531a12c\"\"\"\n                if begin and end:\n                    if begin[1] and end[1]:\n                        constraints.append(\"[{}..{}]\".format(begin[0], end[0]))\n                    elif begin[1]:\n                        constraints.append(\"[{}..{})\".format(begin[0], end[0]))\n                    elif end[1]:\n                        constraints.append(\"({}..{}]\".format(begin[0], end[0]))\n                    else:\n                        constraints.append(\"({}..{})\".format(begin[0], end[0]))\n                elif begin:\n                    if begin[1]:\n                        constraints.append(\"[{}..]\".format(begin[0]))\n                    else:\n                        constraints.append(\"({}..]\".format(begin[0]))\n                elif end:\n                    if end[1]:\n                        constraints.append(\"[..{}]\".format(end[0]))\n                    else:\n                        constraints.append(\"[..{})\".format(end[0]))\n\n            begin = None\n            end = None\n            for key, val in sorted(specs, key=lambda x: x[1]):\n                # if begin, then it is already in a range\n                if key == \"==\":\n                    if begin and end:\n                        add_range(begin, end)\n                        begin = None\n                        end = None\n                    if not begin:\n                        constraints.append(\"[{}]\".format(val))\n\n                if key == \">\":\n                    if end:\n                        add_range(begin, end)\n                        end = None\n                        begin = None\n                    if not begin:\n                        begin = (val, False)\n                if key == \">=\":\n                    if end:\n                        add_range(begin, end)\n                        begin = None\n                        end = None\n                    if not begin:\n                        begin = (val, True)\n\n                if key == \"<\":\n                    end = (val, False)\n                if key == \"<=\":\n                    end = (val, True)\n            add_range(begin, end)\n\n            res.append(\n                {\"forge\": \"PyPI\", \"product\": req.name, \"constraints\": constraints}\n            )\n\n        return res\n\n    def get_modules(self):\n        \"\"\"ID: 2a6bf634-b815-4ecf-87ae-7106a04b1e8a\"\"\"\n        mods = {}\n\n        for modname, module in self.internal_mods.items():\n            name = self.to_uri(modname)\n            filename = module[\"filename\"]\n            namespaces = module[\"methods\"]\n\n            mods[name] = {\"sourceFile\": filename, \"namespaces\": {}}\n\n            for namespace, info in namespaces.items():\n                namespace_uri = self.to_uri(modname, info[\"name\"])\n\n                unique = self.get_unique_and_increment()\n                mods[name][\"namespaces\"][unique] = dict(\n                    namespace=namespace_uri,\n                    metadata=dict(first=info[\"first\"], last=info[\"last\"]),\n                )\n                self.namespace_map[namespace_uri] = unique\n\n        return mods\n\n    def class_hiearchy(self):\n        \"\"\"ID: 3bebd7c7-60c0-4ff1-b364-8da18f4b25f0\"\"\"\n        hierarchy = {}\n        for cls_name, cls in self.classes.items():\n            cls_uri = self.namespace_map.get(self.to_uri(cls[\"module\"], cls_name))\n            hierarchy[cls_uri] = []\n            for parent in cls[\"mro\"]:\n                if parent == cls_name:\n                    continue\n\n                if self.classes.get(parent):\n                    parent_uri = self.to_uri(self.classes[parent][\"module\"], parent)\n                    parent_uri = self.namespace_map.get(parent_uri, parent_uri)\n                else:\n                    parent_mod = parent.split(\".\")[0]\n                    parent_uri = self.to_external_uri(parent_mod, parent)\n\n                hierarchy[cls_uri].append(parent_uri)\n\n        return hierarchy\n\n    def create_namespaces_map(self):\n        \"\"\"ID: b39f969c-8b1b-4723-af74-9144f3be64ee\"\"\"\n        namespaces_maps = [{}, {}]\n        for res, hmap in zip(namespaces_maps, [self.internal_mods, self.external_mods]):\n            for mod in hmap:\n                for namespace in hmap[mod][\"methods\"]:\n                    res[namespace] = mod\n\n        return namespaces_maps\n\n    def get_graph(self):\n        \"\"\"ID: 2b16aa17-f128-4479-96e9-555acdadb389\"\"\"\n        graph = {\"internalCalls\": [], \"externalCalls\": []}\n\n        internal, external = self.create_namespaces_map()\n\n        for src, dst in self.edges:\n            uris = []\n            for node in [src, dst]:\n                if node in internal:\n                    mod = internal[node]\n                    uri = self.to_uri(mod, node)\n                    uris.append(self.namespace_map.get(uri, uri))\n                elif node in external:\n                    mod = external[node]\n                    uris.append(self.to_external_uri(mod, node))\n\n            if len(uris) == 2:\n                # internal uris have been converted to ints\n                if type(uris[1]) == str and uris[1].startswith(\"//\"):\n                    graph[\"externalCalls\"].append([uris[0], uris[1]])\n                else:\n                    graph[\"internalCalls\"].append([uris[0], uris[1]])\n        return graph\n\n    def generate(self):\n        \"\"\"ID: 11c242a3-876a-4b5f-af32-2e69cec19e4c\"\"\"\n        return {\n            \"product\": self.product,\n            \"forge\": self.forge,\n            \"generator\": \"PyCG\",\n            \"depset\": self.find_dependencies(self.package),\n            \"version\": self.version,\n            \"timestamp\": self.timestamp,\n            \"modules\": self.get_modules(),\n            \"cha\": self.class_hiearchy(),\n            \"graph\": self.get_graph(),\n        }",
  "position": {
    "line_no": 25,
    "col_offset": 0,
    "end_line_no": 253,
    "end_col_offset": 0
  }
}