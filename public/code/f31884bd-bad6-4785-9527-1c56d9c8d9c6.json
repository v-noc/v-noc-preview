{
  "id": "nodes/f31884bd-bad6-4785-9527-1c56d9c8d9c6",
  "name": "base",
  "node_type": "file",
  "qname": "Jarvis.processing.base",
  "file_path": "/Users/yared/Documents/Programing/personal/pythonJaRvis.github.io/Jarvis/tool/Jarvis/processing/base.py",
  "file_name": "base",
  "code": "# Copyright [pythonJaRvis] [name of copyright owner]\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"FileID: f31884bd-bad6-4785-9527-1c56d9c8d9c6\"\"\"\nimport ast\nimport os\nfrom functools import reduce\nimport utils\nfrom machinery.definitions import Definition\n\n\nclass ProcessingBase(ast.NodeVisitor):\n    \"\"\"ID: 27b9b317-711f-409a-b032-f3a1d96a8eb1\"\"\"\n\n    def __init__(self, filename, modname, modules_analyzed):\n        \"\"\"ID: dfb5fb19-13cc-489e-a619-59e3ed4cc2a0\"\"\"\n        self.modname = modname\n\n        self.modules_analyzed = modules_analyzed\n        self.modules_analyzed.add(self.modname)\n\n        self.filename = os.path.abspath(filename)\n        print(filename)\n        with open(filename, \"rt\", errors=\"ignore\") as f:\n            self.contents = f.read()\n        self.name_stack = []\n        self.method_stack = []\n        self.last_called_names = None\n        # self.callStack = [modname]\n        self.callStack = []\n\n    def pushStack(self, ns):\n        \"\"\"ID: 846ffa92-7095-438a-ab5f-8c2f1b6ba4de\"\"\"\n        self.callStack.append(ns)\n        self.current_ns = self.callStack[-1]\n        body = self.node_manager.get(ns)\n        self.visit(body)\n        pass\n\n    def popStack(self):\n        \"\"\"ID: 4f9d1d2e-701f-4113-854a-5c078b9c5643\"\"\"\n        ns = self.callStack.pop()\n        changeDict = self.change_manager.getChange(ns)\n        pass\n\n    def get_modules_analyzed(self):\n        \"\"\"ID: 93a19904-6289-4ef6-9b3e-bad83779fb4b\"\"\"\n        return self.modules_analyzed\n\n    def merge_modules_analyzed(self, analyzed):\n        \"\"\"ID: 173852e5-4d50-4bbb-8ac4-48bd54821858\"\"\"\n        self.modules_analyzed = self.modules_analyzed.union(analyzed)\n\n    @property\n    def current_ns(self):\n        \"\"\"ID: cf8a126e-e142-45a9-9fd8-96101029bdb5\"\"\"\n        return self.callStack[-1] if self.callStack else \".\".join(self.name_stack)\n\n    @property\n    def current_method(self):\n        \"\"\"ID: 08c4ac54-4da2-413f-adf0-e48d8922d317\"\"\"\n        return \".\".join(self.method_stack)\n\n    def visit_Module(self, node):\n        \"\"\"ID: e1e7e0bb-4ebe-4933-9d19-cafb3263eb87\"\"\"\n        self.name_stack.append(self.modname)\n        self.method_stack.append(self.modname)\n        self.scope_manager.get_scope(self.modname).reset_counters()\n        self.generic_visit(node)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_FunctionDef(self, node):\n        \"\"\"ID: 30cf055e-4a70-446b-a016-640e286d3d5b\"\"\"\n        self.name_stack.append(node.name)\n        self.method_stack.append(node.name)\n        for stmt in node.body:\n            self.visit(stmt)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_Lambda(self, node, lambda_name=None):\n        \"\"\"ID: e87c7634-d9d7-4c45-8407-d346b7de812e\"\"\"\n        self.name_stack.append(lambda_name)\n        self.method_stack.append(lambda_name)\n        self.visit(node.body)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_If(self, node, if_name=None):\n        \"\"\"ID: 7fa07800-3be0-40de-9478-44a179a078e8\"\"\"\n        self.name_stack.append(if_name)\n        self.method_stack.append(if_name)\n        for stmt in node.body:\n            self.visit(stmt)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_With(self, node, if_name=None):\n        \"\"\"ID: 2851c6d3-46d9-49d0-872c-8d473e001c68\"\"\"\n        self.name_stack.append(if_name)\n        self.method_stack.append(if_name)\n        for stmt in node.body:\n            self.visit(stmt)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_While(self, node, while_name=None):\n        \"\"\"ID: b4548824-2379-4d34-9e71-554bf00450c7\"\"\"\n        self.name_stack.append(while_name)\n        self.method_stack.append(while_name)\n        for stmt in node.body:\n            self.visit(stmt)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_else(self, node, else_name=None):\n        \"\"\"ID: 9412cf58-6ed6-436d-850d-78bc044a9d2e\"\"\"\n        self.name_stack.append(else_name)\n        self.method_stack.append(else_name)\n        for stmt in node.orelse:\n            self.visit(stmt)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_while_else(self, node, else_name=None):\n        \"\"\"ID: 2b593a27-a675-4a00-b30a-5991cb41080c\"\"\"\n        self.visit_else(node, else_name)\n\n    def visit_For(self, node):\n        \"\"\"ID: cd163fcf-6da1-4eaf-b862-ef064baa0597\"\"\"\n        for item in node.body:\n            self.visit(item)\n\n    def visit_Dict(self, node, listNode=None):\n        \"\"\"ID: 90bf2094-ebd5-4e44-8320-832e4b654121\"\"\"\n        # if not self.scope_manager.get_scope(self.current_ns):\n        #     return\n        # counter = self.scope_manager.get_scope(self.current_ns).inc_dict_counter()\n        # dict_name = utils.get_dict_name(counter)\n        #\n        # sc = self.scope_manager.get_scope(utils.join_ns(self.current_ns, dict_name))\n        # if not sc:\n        #     for key, val in zip(node.keys, node.values):\n        #         if key:\n        #             self.visit(key)\n        #         if val:\n        #             self.visit(val)\n        #     return\n        # self.name_stack.append(dict_name)\n        # sc.reset_counters()\n        for key, val in zip(node.keys, node.values):\n            if key:\n                self.visit(key)\n            if val:\n                self.visit(val)\n        # self.name_stack.pop()\n\n    def visit_List(self, node, listNode=None):\n        \"\"\"ID: e419ab34-fca3-43ba-aebd-8dde5fbcefc5\"\"\"\n        # if not self.scope_manager.get_scope(self.current_ns):\n        #     return\n        # counter = self.scope_manager.get_scope(self.current_ns).inc_list_counter()\n        # list_name = utils.get_list_name(counter)\n        #\n        # sc = self.scope_manager.get_scope(utils.join_ns(self.current_ns, list_name))\n        # if not sc:\n        #     return\n        # self.name_stack.append(list_name)\n        # sc.reset_counters()\n        for elt in node.elts:\n            self.visit(elt)\n        # self.name_stack.pop()\n\n    def visit_BinOp(self, node):\n        \"\"\"ID: dbd1c301-f481-4d4d-9946-f203027ef17d\"\"\"\n        self.visit(node.left)\n        self.visit(node.right)\n\n    def visit_ClassDef(self, node):\n        \"\"\"ID: 7781401c-efd9-4d28-9a4a-e826c4e9418e\"\"\"\n        self.name_stack.append(node.name)\n        self.method_stack.append(node.name)\n        curScope = self.scope_manager.get_scope(self.current_ns)\n\n        if curScope:\n            curScope.reset_counters()\n        clsRetNs = utils.join_ns(self.current_ns, utils.constants.RETURN_NAME)\n        clsRetDefi: Definition = self.def_manager.get(clsRetNs)\n        if not clsRetDefi:\n            clsRetDefi = self.def_manager.create(\n                clsRetNs, utils.constants.NAME_DEF)\n        clsSelfNs = utils.join_ns(self.current_ns, 'self')\n        clsSelfDefi: Definition = self.def_manager.get(clsSelfNs)\n        if not clsSelfDefi:\n            clsSelfDefi = self.def_manager.create(\n                clsSelfNs, utils.constants.NAME_DEF)\n        clsRetDefi.add_value_point(node.lineno, [self.current_ns])\n        clsSelfDefi.add_value_point(node.lineno, [self.current_ns])\n        for stmt in node.body:\n            self.visit(stmt)\n        self.method_stack.pop()\n        self.name_stack.pop()\n\n    def visit_Tuple(self, node):\n        \"\"\"ID: 0ab28b04-39f4-4712-8595-9706bef69eca\"\"\"\n        for elt in node.elts:\n            self.visit(elt)\n\n    def _handle_assign(self, targetns, decoded, row=0, defiType=utils.constants.NAME_DEF):\n        \"\"\"ID: f14dd175-b15f-4a37-883a-ceedf47a4a37\"\"\"\n        defi: Definition = self.def_manager.get(targetns)\n        if not defi:\n            defi = self.def_manager.create(targetns, defiType)\n        if defi.get_type == utils.constants.NA_DEF:\n            defi.def_type = utils.constants.NAME_DEF\n        try:\n            iter(decoded)\n        except TypeError:\n            return defi\n        defi.add_value_point(row, decoded)\n        return defi\n\n    def _visit_return(self, node):\n        \"\"\"ID: 05673d3b-0171-41f2-b548-8be415675816\"\"\"\n        if not node or not node.value:\n            return\n\n        self.visit(node.value)\n\n        return_ns = utils.join_ns(self.current_ns, utils.constants.RETURN_NAME)\n        self._handle_assign(return_ns, self.decode_node(node.value))\n\n    def _visit_assign(self, value, targets):\n        \"\"\"ID: 2af62346-1d9a-4795-a955-702151e50ac6\"\"\"\n        self.visit(value)\n\n        decoded = self.decode_node(value)\n\n        def do_assign(decoded, target):\n            \"\"\"ID: b7c2c1bc-b3e7-4f95-8666-c5f568a5c90d\"\"\"\n            self.visit(target)\n            # \u5143\u7ec4\u9700\u8981\u89e3\u6784\n            if isinstance(target, ast.Tuple):\n                for pos, elt in enumerate(target.elts):\n                    if not isinstance(decoded, Definition) and pos < len(decoded):\n                        do_assign(decoded[pos], elt)\n            else:\n                targetns = self._get_target_ns(target)\n                for tns in targetns:\n                    if not tns:\n                        continue\n                    defi = self._handle_assign(tns, decoded)\n                    splitted = tns.split(\".\")\n                    self.scope_manager.handle_assign(\n                        \".\".join(splitted[:-1]), splitted[-1], defi)\n\n        for target in targets:\n            do_assign(decoded, target)\n\n    def decode_node(self, node):\n        \"\"\"ID: 8e1a1326-ae69-4193-a511-ac2b35cf64ec\"\"\"\n        if isinstance(node, ast.Name):\n            return [self.scope_manager.get_def(self.current_ns, node.id)]\n        elif isinstance(node, ast.Call):\n            decoded = self.decode_node(node.func)\n            return_defs = []\n            for called_def in decoded:\n                if not isinstance(called_def, Definition):\n                    continue\n                return_ns = utils.constants.INVALID_NAME\n                # \u5982\u679c\u6536func\uff0c\u5219\u6307\u5411\u5176\u8fd4\u56de\u503c\n                if called_def.get_type() == utils.constants.FUN_DEF:\n                    return_ns = utils.join_ns(\n                        called_def.get_ns(), utils.constants.RETURN_NAME)\n                #     \u5982\u679c\u662fcls\uff0c\u6307\u5411\u5176\u7c7b\n                elif called_def.get_type() == utils.constants.CLS_DEF:\n                    return_ns = called_def.get_ns()\n                #     \u5982\u679c\u662fext\uff0c\u6307\u5411\u5176\u7c7b\uff0c\u7136\u540e\u5728\u540e\u7eed\u7684\u89e3\u6790\u4e2d\u5b8c\u5584\n                elif called_def.get_type() == utils.constants.EXT_DEF:\n                    return_ns = called_def.get_ns()\n                defi = self.def_manager.get(return_ns)\n                if defi:\n                    return_defs.append(defi)\n\n            return return_defs\n        elif isinstance(node, ast.Lambda):\n            lambda_counter = self.scope_manager.get_scope(\n                self.current_ns).get_lambda_counter()\n            lambda_name = utils.get_lambda_name(lambda_counter)\n            return [self.scope_manager.get_def(self.current_ns, lambda_name)]\n        elif isinstance(node, ast.Tuple):\n            decoded = []\n            for elt in node.elts:\n                decoded.append(self.decode_node(elt))\n            return decoded\n        elif isinstance(node, ast.BinOp):\n            decoded_left = self.decode_node(node.left)\n            decoded_right = self.decode_node(node.right)\n            # return the non definition types if we're talking about a binop\n            # since we only care about the type of the return (num, str, etc)\n            if not isinstance(decoded_left, Definition):\n                return decoded_left\n            if not isinstance(decoded_right, Definition):\n                return decoded_right\n        elif isinstance(node, ast.Attribute):\n            names = self._retrieve_attribute_names(node)\n            defis = []\n            for name in names:\n                defi = self.def_manager.get(name)\n                if defi:\n                    defis.append(defi)\n            return defis\n        elif isinstance(node, ast.Num):\n            return [node.n]\n        elif isinstance(node, ast.Str):\n            return [node.s]\n        elif self._is_literal(node):\n            return [node]\n        elif isinstance(node, ast.Dict):\n            dict_counter = self.scope_manager.get_scope(\n                self.current_ns).get_dict_counter()\n            dict_name = utils.get_dict_name(dict_counter)\n            scope_def = self.scope_manager.get_def(self.current_ns, dict_name)\n            return [self.scope_manager.get_def(self.current_ns, dict_name)]\n        elif isinstance(node, ast.List):\n            list_counter = self.scope_manager.get_scope(\n                self.current_ns).get_list_counter()\n            list_name = utils.get_list_name(list_counter)\n            scope_def = self.scope_manager.get_def(self.current_ns, list_name)\n            return [self.scope_manager.get_def(self.current_ns, list_name)]\n        elif isinstance(node, ast.Subscript):\n            names = self.retrieve_subscript_names(node)\n            defis = []\n            for name in names:\n                defi = self.def_manager.get(name)\n                if defi:\n                    defis.append(defi)\n            return defis\n\n        return []\n\n    def _is_literal(self, item):\n        \"\"\"ID: 8cd5fcba-9940-4cbd-96ad-0716baa8dabc\"\"\"\n        return isinstance(item, int) or isinstance(item, str) or isinstance(item, float)\n\n    def _retrieve_base_names(self, node):\n        \"\"\"ID: 6d70db9c-9094-4525-8fc2-3a5ec720a6e6\"\"\"\n        if not isinstance(node, ast.Attribute):\n            raise Exception(\"The node is not an attribute\")\n\n        decoded = self.decode_node(node.value)\n        if not decoded:\n            return set()\n\n        names = set()\n        for name in decoded:\n            if not name or not isinstance(name, Definition):\n                continue\n            names.add(name.get_ns())\n            # for base in self.closured.get(name.get_ns(), []):\n            #     cls = self.class_manager.get(base)\n            #     if not cls:\n            #         continue\n            #\n            #     for item in cls.get_mro():\n            #         names.add(item)\n        return names\n\n    def _retrieve_parent_names(self, node):\n        \"\"\"ID: 9939277b-92e9-4438-b6a5-b75d31fad58d\"\"\"\n        if not isinstance(node, ast.Attribute):\n            raise Exception(\"The node is not an attribute\")\n\n        decoded = self.decode_node(node.value)\n        if not decoded:\n            return set()\n\n        names = set()\n        for parent in decoded:\n            if not parent or not isinstance(parent, Definition):\n                continue\n            if getattr(self, \"closured\", None) and self.closured.get(parent.get_ns(), None):\n                names = names.union(self.closured.get(parent.get_ns()))\n            else:\n                names.add(parent.get_ns())\n        return names\n\n    def _retrieve_attribute_names(self, node):\n        \"\"\"ID: 85b6196c-9cc3-4577-8d0d-43ffe1df7345\"\"\"\n        if not getattr(self, \"closured\", None):\n            return set()\n\n        parent_names = self._retrieve_parent_names(node)\n        names = set()\n        for parent_name in parent_names:\n            for name in self.closured.get(parent_name, []):\n                defi = self.def_manager.get(name)\n                if not defi:\n                    continue\n                if defi.get_type() == utils.constants.CLS_DEF:\n                    cls_names = self.find_cls_fun_ns(defi.get_ns(), node.attr)\n                    if cls_names:\n                        names = names.union(cls_names)\n                if defi.get_type() in [utils.constants.FUN_DEF, utils.constants.MOD_DEF]:\n                    names.add(utils.join_ns(name, node.attr))\n                if defi.get_type() == utils.constants.EXT_DEF:\n                    # HACK: extenral attributes can lead to infinite loops\n                    # Identify them here\n                    if node.attr in name:\n                        continue\n                    ext_name = utils.join_ns(name, node.attr)\n                    if not self.def_manager.get(ext_name):\n                        self.def_manager.create(\n                            ext_name, utils.constants.EXT_DEF)\n                    names.add(ext_name)\n        return names\n\n    def iterate_call_args(self, defi, node):\n        \"\"\"ID: 5fff469b-20a4-483a-8b19-b63422a22a82\"\"\"\n        for pos, arg in enumerate(node.args):\n            self.visit(arg)\n            decoded = self.decode_node(arg)\n            if defi.is_function_def():\n                pos_arg_names = defi.get_name_pointer().get_pos_arg(pos)\n                # if arguments for this position exist update their namespace\n                if not pos_arg_names:\n                    continue\n                for name in pos_arg_names:\n                    arg_def = self.def_manager.get(name)\n                    if not arg_def:\n                        continue\n                    for d in decoded:\n                        if isinstance(d, Definition):\n                            arg_def.get_name_pointer().add(d.get_ns())\n                        else:\n                            arg_def.get_lit_pointer().add(d)\n            else:\n                for d in decoded:\n                    if isinstance(d, Definition):\n                        defi.get_name_pointer().add_pos_arg(pos, None, d.get_ns())\n                    else:\n                        defi.get_name_pointer().add_pos_lit_arg(pos, None, d)\n\n        for keyword in node.keywords:\n            self.visit(keyword.value)\n            decoded = self.decode_node(keyword.value)\n            if defi.is_function_def():\n                arg_names = defi.get_name_pointer().get_arg(keyword.arg)\n                if not arg_names:\n                    continue\n                for name in arg_names:\n                    arg_def = self.def_manager.get(name)\n                    if not arg_def:\n                        continue\n                    for d in decoded:\n                        if isinstance(d, Definition):\n                            arg_def.get_name_pointer().add(d.get_ns())\n                        else:\n                            arg_def.get_lit_pointer().add(d)\n            else:\n                for d in decoded:\n                    if isinstance(d, Definition):\n                        defi.get_name_pointer().add_arg(keyword.arg, d.get_ns())\n                    else:\n                        defi.get_name_pointer().add_lit_arg(keyword.arg, d)\n\n    # def retrieve_subscript_names(self, node):\n    #     if not isinstance(node, ast.Subscript):\n    #         raise Exception(\"The node is not an subcript\")\n    #\n    #\n    #     if getattr(node.slice, \"value\", None) is not None and self._is_literal(node.slice.value):\n    #         sl_names = [node.slice.value]\n    #     else:\n    #         sl_names = self.decode_node(node.slice)\n    #\n    #     val_names = self.decode_node(node.value)\n    #\n    #     decoded_vals = set()\n    #     keys = set()\n    #     full_names = set()\n    #     # get all names associated with this variable name\n    #     for n in val_names:\n    #         if n and isinstance(n, Definition):\n    #             # decoded_vals |= self.closured.get(n.get_ns())\n    #             decoded_vals.add(n.get_ns())\n    #     for s in sl_names:\n    #         if isinstance(s, Definition):\n    #             keys.add(s.get_ns())\n    #             # for name in self.closured.get(s.get_ns()):\n    #             #     defi = self.def_manager.get(name)\n    #             #     if not defi:\n    #             #         continue\n    #             #     keys |= defi.get_lit_pointer().get()\n    #         elif isinstance(s, str):\n    #             keys.add(s)\n    #         elif isinstance(s, int):\n    #             keys.add(s)\n    #\n    #     for d in decoded_vals:\n    #         for key in keys:\n    #             # check for existence of var name and key combination\n    #             str_key = str(key)\n    #             if isinstance(key, int):\n    #                 # str_key = utils.get_int_name(key)\n    #                 str_key = key\n    #             full_ns = utils.join_ns(d, str_key)\n    #             full_names.add(full_ns)\n    #\n    #\n    #     return full_names\n\n    def retrieve_subscript_names(self, node, literFlag=False):\n        \"\"\"ID: 1cd8b67b-fd10-48ef-b508-f3bd9efe8280\"\"\"\n        if not isinstance(node, ast.Subscript):\n            raise Exception(\"The node is not an subcript\")\n        if getattr(node.slice, \"value\", None) is not None and self._is_literal(node.slice.value):\n            sl_names = [node.slice.value]\n        else:\n            sl_names = self.decode_node(node.slice)\n\n        val_names = self.decode_node(node.value)\n\n        decoded_vals = set()\n        keys = set()\n        full_names = set()\n        # get all names associated with this variable name\n        for n in val_names:\n            if n and isinstance(n, Definition):\n                # decoded_vals |= self.closured.get(n.get_ns())\n                decoded_vals.add(n.get_ns())\n        for s in sl_names:\n            if isinstance(s, Definition):\n                keys.add(s.get_ns())\n            elif isinstance(s, str):\n                keys.add(s)\n            elif isinstance(s, int):\n                keys.add(s)\n        returnDefins = set()\n        for d in decoded_vals:\n            definsList = self.resolve(d, node.lineno)\n            for defins in definsList:\n                defi: Definition = self.def_manager.get(defins)\n                if defi and defi.get_type() in [utils.constants.LIST_DEF, utils.constants.MAP_DEF]:\n                    if hasattr(defi, 'memo'):\n                        defiList = set(\n                            reduce(lambda x, y: x + y, defi.memo.values()))\n\n                        # defiList = set(map(lambda x:self.resolveList(x,node.lineno),defiList))\n                        returnDefins = returnDefins.union(defiList)\n            # for key in keys:\n            #     # check for existence of var name and key combination\n            #     definsList = self.resolve(d,node.lineno)\n            #     for defins in definsList:\n            #         defi:Definition = self.def_manager.get(defins)\n            #         if defi and defi.get_type() == utils.constants.LIST_DEF:\n            #             # defi:Definition = self.def_manager.get(defins)\n            #             # if not defi:\n            #             #     continue\n            #             defiList = defi.get_element(key)\n            #             # defiList = set(map(lambda x:self.resolveList(x,node.lineno),defiList))\n            #             returnDefins = returnDefins.union(set(defiList))\n\n        return returnDefins\n\n        # return full_names\n\n    def retrieve_call_names(self, node):\n        \"\"\"ID: 66df552c-b457-436a-b816-f6c0c6f8dc57\"\"\"\n        names = set()\n        if isinstance(node.func, ast.Name):\n            defi = self.scope_manager.get_def(self.current_ns, node.func.id)\n            if defi:\n                names = self.closured.get(defi.get_ns(), None)\n        elif isinstance(node.func, ast.Call) and self.last_called_names:\n            for name in self.last_called_names:\n                return_ns = utils.join_ns(name, utils.constants.RETURN_NAME)\n                returns = self.closured.get(return_ns)\n                if not returns:\n                    continue\n                for ret in returns:\n                    defi = self.def_manager.get(ret)\n                    names.add(defi.get_ns())\n        elif isinstance(node.func, ast.Attribute):\n            names = self._retrieve_attribute_names(node.func)\n        elif isinstance(node.func, ast.Subscript):\n            # Calls can be performed only on single indices, not ranges\n            full_names = self.retrieve_subscript_names(node.func)\n            for n in full_names:\n                if self.closured.get(n, None):\n                    names |= self.closured.get(n)\n\n        return names\n\n    def analyze_submodules(self, cls, *args, **kwargs):\n        \"\"\"ID: 36bdab9a-ba16-41fa-88d9-133c7a8552b8\"\"\"\n        imports = self.import_manager.get_imports(self.modname)\n\n        for imp in imports:\n            self.analyze_submodule(cls, imp, *args, **kwargs)\n\n    def analyze_submodule(self, cls, imp, *args, **kwargs):\n        \"\"\"ID: e9dc3483-725a-43e0-b18e-a4c1815bf314\"\"\"\n        if imp in self.get_modules_analyzed():\n            return\n\n        fname = self.import_manager.get_filepath(imp)\n        if not fname:\n            return\n        if fname.endswith(\".so\"):\n            return\n        # if not fname or not self.import_manager.get_mod_dir() in fname:\n        #     return\n\n        self.import_manager.set_current_mod(imp, fname)\n\n        visitor = cls(fname, imp, *args, **kwargs)\n        visitor.analyze()\n        self.merge_modules_analyzed(visitor.get_modules_analyzed())\n\n        # self.import_manager.set_current_mod(self.modname, self.filename)\n        self.setMod()\n\n    def setMod(self):\n        \"\"\"ID: b2ca4881-2c0d-4992-bce7-8844d70ae07c\"\"\"\n        imp = self.module_manager.get(self.get_module_ns(self.current_ns))\n        if not imp:\n            print()\n        self.import_manager.set_current_mod(imp.name, imp.filename)\n\n    def find_cls_fun_ns(self, cls_name, fn):\n        \"\"\"ID: a9943e1f-ae57-41e6-ac50-6dd66683c334\"\"\"\n        cls = self.class_manager.get(cls_name)\n        if not cls:\n            return set()\n\n        ext_names = set()\n        for item in cls.get_mro():\n            ns = utils.join_ns(item, fn)\n            names = set()\n            if getattr(self, \"closured\", None) and self.closured.get(ns, None):\n                names = self.closured[ns]\n            else:\n                names.add(ns)\n\n            if self.def_manager.get(ns):\n                return names\n\n            parent = self.def_manager.get(item)\n            if parent and parent.get_type() == utils.constants.EXT_DEF:\n                ext_names.add(ns)\n\n        for name in ext_names:\n            self.def_manager.create(name, utils.constants.EXT_DEF)\n            self.add_ext_mod_node(name)\n        return ext_names\n\n    def add_ext_mod_node(self, name):\n        \"\"\"ID: 8c28ed12-e9c9-4159-b0cb-134f2bae8336\"\"\"\n\n        ext_modname = name.split(\".\")[0]\n        ext_mod = self.module_manager.get(ext_modname)\n        if not ext_mod:\n            ext_mod = self.module_manager.create(\n                ext_modname, None, external=True)\n            ext_mod.add_method(ext_modname)\n\n        ext_mod.add_method(name)\n"
}