[
  {
    "_key": "423c9a67-d7c7-451f-a68d-84d7754849ff",
    "_id": "documents/423c9a67-d7c7-451f-a68d-84d7754849ff",
    "created_at": "2026-01-26T07:35:53.980090Z",
    "updated_at": "2026-01-26T07:37:47.291946Z",
    "name": "Overview",
    "description": "overview",
    "data": "[{\"id\":\"850ff559-1738-44bb-adb7-8faaefb116d6\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":1,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Group: Namespace & Scope Resolution\",\"styles\":{}}],\"children\":[]},{\"id\":\"45615e9d-1a2b-4208-b668-449164024b44\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"These functions are dedicated to calculating and retrieving specific namespace strings. They translate raw names or scopes into fully qualified namespaces used internally to track variables. By mapping identifiers like \",\"styles\":{}},{\"type\":\"text\",\"text\":\"my_func\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" to absolute paths like \",\"styles\":{}},{\"type\":\"text\",\"text\":\"module.class.my_func\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", they ensure that the analyzer can differentiate between identical names in different parts of a project.\",\"styles\":{}}],\"children\":[]},{\"id\":\"93697bd7-ac88-45d9-b71b-22dbcbed3967\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"00eef5c0-6199-4022-aa00-bec55373dd6c\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":2,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Function Descriptions\",\"styles\":{}}],\"children\":[]},{\"id\":\"f5187e26-5962-483c-b327-a44ebbd794f1\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"get_module_ns\",\"styles\":{}}],\"children\":[]},{\"id\":\"8de352e9-5d09-4514-887b-048d9c3f8fbb\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Resolves and returns the module-level namespace for a given definition namespace. It walks up the namespace hierarchy until a module definition is found, ensuring that functions or classes can be correctly associated with their containing module.\",\"styles\":{}}],\"children\":[]},{\"id\":\"29af0a16-f22b-4139-b56b-cf6ecabf0423\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"In complex projects, many operations (like resolving relative imports) require knowing the \\\"root\\\" file context. This function provides that context by stripping away nested function or class identifiers until only the module path remains.\",\"styles\":{}}],\"children\":[]},{\"id\":\"415df1a7-276c-4d02-95a1-fdecf16fc82f\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"handle\",\"styles\":{\"italic\":true}},{\"type\":\"text\",\"text\":\"ns\",\"styles\":{}}],\"children\":[]},{\"id\":\"c69c66ba-c69f-48e9-b285-689f85bc6836\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Determines the effective current namespace for analysis by skipping temporary control\u2011flow scopes such as \",\"styles\":{}},{\"type\":\"text\",\"text\":\"if\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", \",\"styles\":{}},{\"type\":\"text\",\"text\":\"else\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", and \",\"styles\":{}},{\"type\":\"text\",\"text\":\"while\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\". It walks up the call stack until it reaches a stable definition, returning the namespace that should own newly created definitions.\",\"styles\":{}}],\"children\":[]},{\"id\":\"e50b9718-c7f5-4a15-add9-9a6a965885ee\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Python treats functions defined inside an \",\"styles\":{}},{\"type\":\"text\",\"text\":\"if\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" block as belonging to the surrounding function or module, not the \",\"styles\":{}},{\"type\":\"text\",\"text\":\"if\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" block itself. This utility ensures that structural definitions are parented correctly in the official namespace hierarchy, rather than being trapped in temporary control-flow labels.\",\"styles\":{}}],\"children\":[]},{\"id\":\"ac4af5eb-abf7-46ae-b5ee-bc8e5cbf2e15\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"get\",\"styles\":{\"italic\":true}},{\"type\":\"text\",\"text\":\"target_ns\",\"styles\":{}}],\"children\":[]},{\"id\":\"9f0a5c79-205c-4f98-9fd6-0d68f93ab557\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Resolves the fully qualified namespace(s) for an assignment target. It supports simple names, attribute accesses, and subscript targets, returning the corresponding namespaces so assignments can be correctly mapped to their definitions.\",\"styles\":{}}],\"children\":[]},{\"id\":\"d2963ebb-843c-4d22-95bb-5471aef9c67e\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"When the analyzer processes \",\"styles\":{}},{\"type\":\"text\",\"text\":\"self.data = 10\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", it needs to know the exact \\\"address\\\" of \",\"styles\":{}},{\"type\":\"text\",\"text\":\"self.data\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\". This function recursively resolves the base object (\",\"styles\":{}},{\"type\":\"text\",\"text\":\"self\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\") and joins it with the attribute (\",\"styles\":{}},{\"type\":\"text\",\"text\":\"data\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\") to generate the unique identifier required for accurate state tracking.\",\"styles\":{}}],\"children\":[]},{\"id\":\"ed7c75ec-43b8-4772-8dd8-52ae09bfd86b\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"get_scope_ns\",\"styles\":{}}],\"children\":[]},{\"id\":\"d311fbc8-9ff3-459f-9335-70d4b61b6326\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Finds and returns the nearest enclosing scope namespace for a given namespace string. It walks up the namespace hierarchy until a matching scope is found, or returns \",\"styles\":{}},{\"type\":\"text\",\"text\":\"None\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" if no valid scope exists.\",\"styles\":{}}],\"children\":[]},{\"id\":\"b6819f92-5919-4047-9017-b31dd225363f\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"This function identifies the \\\"container\\\" for a variable. For an identifier like \",\"styles\":{}},{\"type\":\"text\",\"text\":\"module.func.var\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", the scope is \",\"styles\":{}},{\"type\":\"text\",\"text\":\"module.func\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\". Finding this container is essential for determining variable visibility and ensuring new symbols are registered in the correct logical block.\",\"styles\":{}}],\"children\":[]},{\"id\":\"525ba10c-11d3-42e3-a014-81a8f565b8ed\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[],\"children\":[]}]"
  }
]