[
  {
    "_key": "c15e7819-8f1e-4fa9-8850-abfff83e1405",
    "_id": "documents/c15e7819-8f1e-4fa9-8850-abfff83e1405",
    "created_at": "2026-01-26T08:14:30.653934Z",
    "updated_at": "2026-01-26T08:35:20.335160Z",
    "name": "Overview",
    "description": "overview",
    "data": "[{\"id\":\"1d22bd19-7f89-423f-896c-7be826228246\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":1,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Group: Scope & Attribute Lookup\",\"styles\":{}}],\"children\":[]},{\"id\":\"fd465461-4f07-426b-953c-50e637e2cad6\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"These methods facilitate the search for existing definitions within specific contexts. They handle the mechanics of looking up attributes (fields), class methods, built-in functions, or verifying if a definition exists within a specific scope.\",\"styles\":{}}],\"children\":[]},{\"id\":\"1d335d86-286e-4faa-a84c-f87ebd2627b5\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"By managing the logic of where and how names are found, this group allows the analyzer to handle Python's complex visibility rules. This includes looking up members of objects, resolving inherited methods through class hierarchies, and distinguishing between locally defined variables and those belonging to parent or global scopes.\",\"styles\":{}}],\"children\":[]},{\"id\":\"4b15437f-d3d4-4164-b1c9-fb55835c7e31\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"73277d95-5ec0-4565-999f-c6a6354f43a5\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":2,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Function Descriptions\",\"styles\":{}}],\"children\":[]},{\"id\":\"66d651e9-f9d5-4395-be9b-6e62b813de2c\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"find_field\",\"styles\":{}}],\"children\":[]},{\"id\":\"5abb4ea6-ce60-4220-b0b0-360f2e4f74bb\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Resolves an attribute or method name on a given scope or built\u2011in type. It supports built\u2011in primitives, external definitions, and user\u2011defined classes by locating the appropriate field or method namespace, returning \",\"styles\":{}},{\"type\":\"text\",\"text\":\"None\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" when the attribute cannot be resolved.\",\"styles\":{}}],\"children\":[]},{\"id\":\"6bcda362-8c4d-4686-968b-b6844113f79a\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"In Python, the same attribute access syntax (\",\"styles\":{}},{\"type\":\"text\",\"text\":\"obj.attr\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\") can refer to very different things. This function acts as a central router that applies different lookup strategies\u2014such as checking Python's built-in types (strings, lists) or searching within a class structure\u2014to find the actual definition of the accessed member.\",\"styles\":{}}],\"children\":[]},{\"id\":\"a35c95ce-5bd1-4bc3-879d-b8d844d91961\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"iSDefiInScope\",\"styles\":{}}],\"children\":[]},{\"id\":\"2c263892-f0fa-48bb-b090-28fe301d63de\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Checks whether a given definition exists within a specified scope. It scans the scope\u2019s registered definitions and returns \",\"styles\":{}},{\"type\":\"text\",\"text\":\"True\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" if the target definition is found, helping determine whether assignments should be applied directly or tracked as scoped changes.\",\"styles\":{}}],\"children\":[]},{\"id\":\"b990339e-e393-4905-8880-1f0424e22b5d\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"This utility is vital for correctly handling assignments within conditional blocks. By determining if a variable belongs to the current local block or a parent scope, the analyzer can decide whether to update the variable permanently or record a temporary change that must be merged later.\",\"styles\":{}}],\"children\":[]},{\"id\":\"3f9b56bc-7390-43d2-a1c2-3b8ff4c42fb2\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"find_cls_fun_ns\",\"styles\":{}}],\"children\":[]},{\"id\":\"f2c11da5-1021-4a46-ba46-08b0eab5656d\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Resolves a method name within a class by walking the class\u2019s method resolution order (MRO). It locates the first matching method definition, updates the implicit \",\"styles\":{}},{\"type\":\"text\",\"text\":\"self\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" binding to the current class, and returns the resolved method definition if found.\",\"styles\":{}}],\"children\":[]},{\"id\":\"5458dc70-6307-48c2-9f05-16aaedad9238\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Class inheritance is a core part of object-oriented code. This function allows the analyzer to find methods defined in parent classes and ensures that the \",\"styles\":{}},{\"type\":\"text\",\"text\":\"self\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" variable within those methods is correctly linked to the child class currently being analyzed.\",\"styles\":{}}],\"children\":[]},{\"id\":\"4f6dc122-6fcb-4308-93c8-3f6dcbc35b98\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"mergeLeftRight\",\"styles\":{}}],\"children\":[]},{\"id\":\"c9a3ab55-2d17-42e4-9927-5c867cac6755\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Combines a base namespace with a subsequent attribute segment during point resolution. It checks for valid fields in the corresponding scope, falls back to existing definitions, and ultimately constructs a fully qualified namespace to represent chained attribute access.\",\"styles\":{}}],\"children\":[]},{\"id\":\"8d7c3f30-a683-4ae5-9e85-5d9f9b0e39a7\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Static resolution often happens one \\\"link\\\" at a time (e.g., resolving \",\"styles\":{}},{\"type\":\"text\",\"text\":\"A\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", then \",\"styles\":{}},{\"type\":\"text\",\"text\":\"A.B\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", then \",\"styles\":{}},{\"type\":\"text\",\"text\":\"A.B.C\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"). This function provides the logic to connect a resolved base object with its attributes, effectively traversing the project's object hierarchy.\",\"styles\":{}}],\"children\":[]},{\"id\":\"8c9312ea-030e-471e-bd61-cc129d5c2ddb\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"get_or_create\",\"styles\":{}}],\"children\":[]},{\"id\":\"1b20a059-04ae-4f85-8249-cf04b88c60cf\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Retrieves an existing definition for a name within a namespace or creates one if it does not exist. It ensures the definition is registered in the corresponding scope so subsequent references and assignments are tracked consistently.\",\"styles\":{}}],\"children\":[]},{\"id\":\"4605b80b-4abb-411a-b599-2b214da9209c\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"This function bridges the gap between the global definition list and local visibility. It ensures that every variable name encountered by the analyzer has a formal identity and is correctly \\\"owned\\\" by the code block in which it appears.\",\"styles\":{}}],\"children\":[]},{\"id\":\"fe67a902-98d3-4274-9219-08c91fef8fad\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[],\"children\":[]}]"
  }
]