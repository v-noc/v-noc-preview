[
  {
    "_key": "ba6c909c-a656-41bc-8ea0-1f9eb897f697",
    "_id": "documents/ba6c909c-a656-41bc-8ea0-1f9eb897f697",
    "created_at": "2026-01-26T12:46:11.406019Z",
    "updated_at": "2026-01-26T13:14:08.609203Z",
    "name": "Overview",
    "description": "overview",
    "data": "[{\"id\":\"05b46485-cf62-409f-8c36-23c33e294b37\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":2,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Class Documentation: ScopeManager\",\"styles\":{\"bold\":true}}],\"children\":[]},{\"id\":\"b8f5ebb1-3c77-4f7c-98c5-09aa9fc90cb6\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"The \",\"styles\":{}},{\"type\":\"text\",\"text\":\"ScopeManager\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" serves as the central orchestration unit for the framework's understanding of program structure. It acts as a registry and coordinator for all lexical environments discovered during the analysis, ensuring that the relationships between variables, functions, classes, and their parent modules are accurately maintained.\",\"styles\":{}}],\"children\":[]},{\"id\":\"02de8e77-2934-4b93-9ca9-f68ad12e6c55\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"62513f49-e68f-4169-840a-fb6a494ec554\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Overview\",\"styles\":{\"bold\":true}}],\"children\":[]},{\"id\":\"d7e607b7-758a-45aa-a205-32e953b6ac7b\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"In Python, the meaning of a variable name depends entirely on where it is located (its scope). The \",\"styles\":{}},{\"type\":\"text\",\"text\":\"ScopeManager\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" simulates Python's scoping rules by building a hierarchical tree of \",\"styles\":{}},{\"type\":\"text\",\"text\":\"ScopeItem\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" objects. This allows the analyzer to resolve names, manage synthetic identifiers (like those for lambdas), and track data flow across complex, nested codebases.\",\"styles\":{}}],\"children\":[]},{\"id\":\"e0bc17b2-602e-455a-b235-f5ede7704a4e\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"c98dc7f4-e03b-40f9-9825-515a8dd7eba3\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Core Method Categories\",\"styles\":{\"bold\":true}}],\"children\":[]},{\"id\":\"0fb71c0a-55ae-4a67-9a8c-f6d99edb1ee9\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":4,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"1. Scope Lifecycle & Initialization\",\"styles\":{\"bold\":true}}],\"children\":[]},{\"id\":\"475a5ce3-8724-4b5f-98a4-73350452265d\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Methods in this group focus on the discovery and construction of the environment tree.\",\"styles\":{\"italic\":true}}],\"children\":[]},{\"id\":\"7892df7f-59ba-41a0-b611-a93865700360\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"These methods transform raw source code and file paths into a structured hierarchy. By using Python's internal symbol table (\",\"styles\":{}},{\"type\":\"text\",\"text\":\"symtable\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"), the manager can identify every function and class definition before the deep analysis begins. This phase is crucial because it sets up the \\\"map\\\" of the program, ensuring that every subsequent analysis step knows exactly which parent environment it belongs to.\",\"styles\":{}}],\"children\":[]},{\"id\":\"977c5b80-e55b-44c5-bc2e-56a54364de1c\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":4,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"2. Definition & Symbol Management\",\"styles\":{\"bold\":true}}],\"children\":[]},{\"id\":\"c6d6e195-b467-468d-8486-57b1ba6429e9\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Methods in this group populate the established scopes with semantic data.\",\"styles\":{\"italic\":true}}],\"children\":[]},{\"id\":\"deb284ae-c9bb-4e5d-a34e-82256027eea1\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Once the structural map (the scopes) is ready, these methods are used to record what actually happens inside those scopes. They handle variable assignments, capture function parameters, and register external inputs. By routing these definitions through the manager, the framework ensures that a variable \",\"styles\":{}},{\"type\":\"text\",\"text\":\"x\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" assigned inside \",\"styles\":{}},{\"type\":\"text\",\"text\":\"Function A\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" does not conflict with a variable \",\"styles\":{}},{\"type\":\"text\",\"text\":\"x\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" assigned inside \",\"styles\":{}},{\"type\":\"text\",\"text\":\"Function B\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\".\",\"styles\":{}}],\"children\":[]},{\"id\":\"8f0fe1a3-a9f6-49d6-ba89-110fb4b704fa\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":4,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"3. Lookup & State Resolution\",\"styles\":{\"bold\":true}}],\"children\":[]},{\"id\":\"a4741957-6aaa-42f9-b7ea-1762e4db0c18\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Methods in this group are used to query the hierarchy and track analysis progress.\",\"styles\":{\"italic\":true}}],\"children\":[]},{\"id\":\"eb96ff33-d432-454f-97a7-e11299cf6054\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"These are the \\\"search\\\" and \\\"state\\\" tools. The lookup logic implements the standard \",\"styles\":{}},{\"type\":\"text\",\"text\":\"LEGB\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\" (Local, Enclosing, Global, Built-in) rule, allowing the analyzer to find where a variable was originally defined by climbing up the parent scope links. Additionally, this group includes sequencing tools that track different versions or iterations of a scope, which is vital for analyzing loops and branching logic where the state of a scope may change over time.\",\"styles\":{}}],\"children\":[]},{\"id\":\"ce66d713-afb1-44f6-a5a3-996516830dbd\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"18cbc59b-5e03-485b-b04b-11ce0f917f1f\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Functional Purpose\",\"styles\":{\"bold\":true}}],\"children\":[]},{\"id\":\"1c37ffe3-c029-46e8-9413-10d0730d465b\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"The primary reason for the \",\"styles\":{}},{\"type\":\"text\",\"text\":\"ScopeManager\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" is to provide \",\"styles\":{}},{\"type\":\"text\",\"text\":\"contextual accuracy\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\". Without it, the analyzer would treat code as a flat list of instructions. With it, the analyzer understands that:\",\"styles\":{}}],\"children\":[]},{\"id\":\"7cf190e1-a42d-4a49-9168-9fb39fab374c\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"A variable inside a method has access to the class-level \",\"styles\":{}},{\"type\":\"text\",\"text\":\"self\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\".\",\"styles\":{}}],\"children\":[]},{\"id\":\"3dada0f2-6967-4e36-8349-fa4d96048dfb\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"A lambda function captures variables from its enclosing function.\",\"styles\":{}}],\"children\":[]},{\"id\":\"6bc32cdd-3b8b-4176-9cfe-ea7a26458bf2\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Counters for anonymous objects (like list comprehensions) must be unique per scope to avoid identification collisions in the generated call graph.\",\"styles\":{}}],\"children\":[]},{\"id\":\"f3c07378-29e3-44f4-9a2d-0599edb03ea9\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[],\"children\":[]}]"
  }
]