[
  {
    "_key": "39f7620b-5828-42c6-8d46-1f71530ca1ed",
    "_id": "documents/39f7620b-5828-42c6-8d46-1f71530ca1ed",
    "created_at": "2026-01-26T08:14:39.213553Z",
    "updated_at": "2026-01-26T08:47:03.508630Z",
    "name": "Overview",
    "description": "overview",
    "data": "[{\"id\":\"6deb5b34-0e4e-49c3-92ed-65d6fe670f99\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":1,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Group: Node Decoding & Extraction\",\"styles\":{}}],\"children\":[]},{\"id\":\"12867d54-be82-4666-a33a-37e0641e7b58\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"These methods are responsible for parsing specific raw AST nodes to extract immediate, usable data before deep resolution occurs. They handle the initial translation of syntax trees into the processor's internal data formats.\",\"styles\":{}}],\"children\":[]},{\"id\":\"ea96957b-9278-4d0a-b251-7fc4ad5f8e6c\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"This group acts as the \\\"translator\\\" between the raw Python syntax and the analyzer's semantic model. These methods strip away the complexity of Abstract Syntax Tree nodes to reveal the underlying symbols, literal values, and structural boundaries, providing the clean data required for the resolution and tracking engines to function.\",\"styles\":{}}],\"children\":[]},{\"id\":\"3d7c80a0-9f70-47a9-893d-e69d46c08871\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"852ac46e-280c-4732-b312-ded11b5ac83a\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":2,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Function Descriptions\",\"styles\":{}}],\"children\":[]},{\"id\":\"f4a826a8-15d5-434a-9dcc-7f971f8a9cc9\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"decode_node\",\"styles\":{}}],\"children\":[]},{\"id\":\"f78afbce-e2e0-43db-8d32-4d8f9c4bf296\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Decodes an AST node into the corresponding definitions or literal representations used by the analyzer. It supports names, calls, attributes, lambdas, tuples, literals, collections, and subscripts, creating placeholder definitions when needed so value flow and references can be consistently tracked.\",\"styles\":{}}],\"children\":[]},{\"id\":\"41dd9034-1cc5-4a9d-88ca-1027632ce84a\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"AST nodes are structural containers (e.g., an \",\"styles\":{}},{\"type\":\"text\",\"text\":\"ast.Name\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" node). \",\"styles\":{}},{\"type\":\"text\",\"text\":\"decode_node\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" identifies what that container represents in the project's namespace. It is essential for mapping syntactic expressions to their logical identities, such as turning a variable name into a specific \",\"styles\":{}},{\"type\":\"text\",\"text\":\"Definition\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" object that can be tracked across the codebase.\",\"styles\":{}}],\"children\":[]},{\"id\":\"55365eae-5421-4ec4-8559-8b42d6db8e1a\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"get\",\"styles\":{\"italic\":true}},{\"type\":\"text\",\"text\":\"last_line\",\"styles\":{}}],\"children\":[]},{\"id\":\"664b0fd4-6fde-4bb7-912a-eb4c2873a7dd\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Determines the last source line number covered by a given AST node. It walks all descendant nodes, finds the maximum line number, and ensures the returned value is at least the node\u2019s starting line for accurate source range tracking.\",\"styles\":{}}],\"children\":[]},{\"id\":\"0b354d28-f8b4-41e0-a439-abeb8167ea13\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Python AST nodes usually only store their starting line number. To understand the full physical span of a function or class, the analyzer must find the highest line number among its children. This is crucial for the \",\"styles\":{}},{\"type\":\"text\",\"text\":\"module_manager\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" to define the \\\"territory\\\" of a method or class within a file.\",\"styles\":{}}],\"children\":[]},{\"id\":\"f0b4af52-eb29-4604-a2dc-58d1eea8aaeb\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"get\",\"styles\":{\"italic\":true}},{\"type\":\"text\",\"text\":\"fun_defaults\",\"styles\":{}}],\"children\":[]},{\"id\":\"c7e5177a-b998-4cb1-92db-9f7a73bbbcc9\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Extracts and resolves default argument values for a function definition. It evaluates each default expression, maps it to the corresponding parameter name, and records the resolved value points so default parameter behavior is accurately modeled during analysis.\",\"styles\":{}}],\"children\":[]},{\"id\":\"387c8517-542d-4d04-8438-105812a0b320\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"In Python, default arguments (e.g., \",\"styles\":{}},{\"type\":\"text\",\"text\":\"timeout=30\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\") are part of a function's definition. This method ensures the analyzer knows that even if a function is called without arguments, its parameters still have initial \\\"value points\\\" derived from these defaults, enabling more accurate type inference.\",\"styles\":{}}],\"children\":[]},{\"id\":\"2cc0a2bf-e5cf-4650-bc03-fad028cb58d6\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"retrieve_subscript_names\",\"styles\":{}}],\"children\":[]},{\"id\":\"7fa72f32-791f-43d5-8ec3-c8bff948d1a4\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Resolves subscript expressions by determining all possible element namespaces accessed through indexing or key lookup. It decodes both the container and index, follows value points for lists and maps, and returns the set of definitions that the subscript expression may reference.\",\"styles\":{}}],\"children\":[]},{\"id\":\"ffad6d4c-d4fa-4c79-89c9-ac6690031081\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Data hidden inside collections (like \",\"styles\":{}},{\"type\":\"text\",\"text\":\"config['url']\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\") is often invisible to simple analyzers. This function performs a targeted search into the internal memory (\",\"styles\":{}},{\"type\":\"text\",\"text\":\"memo\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\") of lists and dictionaries to extract specific element definitions, allowing data flow to be tracked through complex data structures.\",\"styles\":{}}],\"children\":[]},{\"id\":\"10bae652-f979-4f1d-8f19-1b355fa2b2cf\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"is_builtin\",\"styles\":{}}],\"children\":[]},{\"id\":\"4a82e053-bf41-4dfb-a4a1-ec61e2506d60\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Description:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"Checks whether a given name refers to a Python built\u2011in identifier. It uses the \",\"styles\":{}},{\"type\":\"text\",\"text\":\"__builtins__\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" namespace to quickly determine if the name should be treated as a built\u2011in function or object during analysis.\",\"styles\":{}}],\"children\":[]},{\"id\":\"88e1dc03-02d6-4c76-a6f2-4be40664906a\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Reasoning:\\n\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\"The analyzer needs to distinguish between user-defined code and standard Python functions (like \",\"styles\":{}},{\"type\":\"text\",\"text\":\"len\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" or \",\"styles\":{}},{\"type\":\"text\",\"text\":\"print\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"). This check prevents the analyzer from searching for source code that doesn't exist for built-ins and allows it to apply specialized handling for standard library behaviors.\",\"styles\":{}}],\"children\":[]},{\"id\":\"23021450-0f16-48c6-a805-35140c990336\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[],\"children\":[]}]"
  }
]