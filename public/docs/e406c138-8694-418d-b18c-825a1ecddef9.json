[
  {
    "_key": "70b6b1ba-4cc0-4ef4-8a7b-20c8f75a57dd",
    "_id": "documents/70b6b1ba-4cc0-4ef4-8a7b-20c8f75a57dd",
    "created_at": "2026-01-26T18:39:37.740480Z",
    "updated_at": "2026-01-26T18:41:11.901321Z",
    "name": "Overview",
    "description": "overview",
    "data": "[{\"id\":\"b0696ff1-2dcf-44bc-ac5d-9c6113af3726\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Group: Scope & Value Resolution\",\"styles\":{}}],\"children\":[]},{\"id\":\"77d57b2a-2edf-4558-8a97-3b67ebdb77d8\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"This group of methods contains the intelligence required to navigate the hierarchical and dynamic nature of Python code. In static analysis, a variable's \\\"value\\\" is often just a pointer to another definition. These methods allow the engine to determine where a variable belongs (lexical scope) and recursively follow assignment chains to find the ultimate source of a value.\",\"styles\":{}}],\"children\":[]},{\"id\":\"9a9b468a-f397-42a5-86d8-25606a2f1ec8\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"7fc4e619-3672-4c8a-a2e9-c421fc146425\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":4,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Methods\",\"styles\":{}}],\"children\":[]},{\"id\":\"d858570a-3353-47f2-8362-f4331f21c28c\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"get_scope_name(ns)\\n\\n\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"Walks up the namespace hierarchy to find the nearest parent that represents a functional scope (a Module, Class, or Function). For example, given \",\"styles\":{}},{\"type\":\"text\",\"text\":\"app.utils.Validator.check.local_var\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", it would resolve to \",\"styles\":{}},{\"type\":\"text\",\"text\":\"app.utils.Validator.check\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\".\",\"styles\":{}}],\"children\":[]},{\"id\":\"0dc48e78-a8a2-48d6-9fce-5346cb83dabe\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"transform_defi(ns, row)\\n\\n\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"Converts a definition's state at a specific line into a list of target namespaces. It specifically follows \\\"name-pointer\\\" relationships, allowing the engine to see what other symbols a variable references at that point in time.\",\"styles\":{}}],\"children\":[]},{\"id\":\"a60766fb-654b-4f74-ac90-a68a2060a6fc\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"get_final_pointName(defiNs, row)\\n\\n\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"Resolves what a definition points to at a specific line. If the definition has no recorded value-flow points, it returns the definition's own namespace as the fallback, effectively saying \\\"this variable points to itself.\\\"\",\"styles\":{}}],\"children\":[]},{\"id\":\"c0dd2d32-8d54-4c09-9305-afcac325e101\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"get_module_name(ns)\\n\\n\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"A specialized version of scope resolution that walks up the hierarchy until it finds the owning \",\"styles\":{}},{\"type\":\"text\",\"text\":\"MOD_DEF\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" (Module Definition). This is critical for determining file-level ownership of a symbol.\",\"styles\":{}}],\"children\":[]},{\"id\":\"575c2ed1-cd4b-46c2-972c-1882d8ba17d7\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"is_same_scope(first, second)\\n\\n\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"A boolean helper that determines if two different namespaces share the same parent scope. This is often used to check for variable shadowing or visibility constraints.\",\"styles\":{}}],\"children\":[]},{\"id\":\"a637bafc-188a-47a2-84b0-d67dff282121\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"get_last_final_pointName(defiNs)\\n\\n\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"Performs a recursive, \\\"deep\\\" resolution of a variable. If \",\"styles\":{}},{\"type\":\"text\",\"text\":\"A\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" points to \",\"styles\":{}},{\"type\":\"text\",\"text\":\"B\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", and \",\"styles\":{}},{\"type\":\"text\",\"text\":\"B\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" points to \",\"styles\":{}},{\"type\":\"text\",\"text\":\"C\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\", calling this on \",\"styles\":{}},{\"type\":\"text\",\"text\":\"A\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" will return \",\"styles\":{}},{\"type\":\"text\",\"text\":\"C\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\". It uses a queue-based traversal to follow these links until it reaches terminal definitions (nodes that don't point to anything else).\",\"styles\":{}}],\"children\":[]},{\"id\":\"d808ceb0-8a30-4839-a12d-0f49a47ca3f6\",\"type\":\"divider\",\"props\":{},\"children\":[]},{\"id\":\"a6a84194-2f5a-4566-9790-940d4309f5bb\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Usage Example\",\"styles\":{}}],\"children\":[]},{\"id\":\"590aa4c9-0459-481a-8a57-e2367087e9cf\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"The analyzer uses these methods to solve \\\"Where does this come from?\\\" questions during data-flow tracking.\",\"styles\":{}}],\"children\":[]},{\"id\":\"f4245607-4cb1-4008-9dbc-7fa50da2c6c7\",\"type\":\"codeBlock\",\"props\":{\"language\":\"python\"},\"content\":[{\"type\":\"text\",\"text\":\"# Assuming the manager has these definitions:\\n# x = y (at line 10)\\n# y = z (at line 5)\\n\\n# 1. Resolve deep assignments\\n# Traces the chain x -> y -> z\\nfinal_targets = dm.get_last_final_pointName(\\\"app.main.x\\\")\\nprint(f\\\"Final source: {final_targets}\\\") # Output: ['app.main.z']\\n\\n# 2. Check scope relationships\\nis_local = dm.is_same_scope(\\\"app.main.x\\\", \\\"app.main.y\\\")\\nprint(f\\\"Are X and Y in the same scope? {is_local}\\\")\\n\\n# 3. Find the owning module\\nmodule = dm.get_module_name(\\\"app.services.auth.login.attempts\\\")\\nprint(f\\\"Owning module: {module}\\\") # Output: app.services.auth\",\"styles\":{}}],\"children\":[]},{\"id\":\"abb3eb5c-f6f9-49f6-9875-de30bc925032\",\"type\":\"heading\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\",\"level\":3,\"isToggleable\":false},\"content\":[{\"type\":\"text\",\"text\":\"Insights\",\"styles\":{}}],\"children\":[]},{\"id\":\"ec9d608e-280d-4bd6-a1a1-e728caab4141\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Recursive Logic\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\": \",\"styles\":{}},{\"type\":\"text\",\"text\":\"get_last_final_pointName\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" is vital for inter-procedural analysis. It ensures that Jarvis doesn't get \\\"stuck\\\" at a temporary alias and instead follows the data back to its original definition or entry point.\",\"styles\":{}}],\"children\":[]},{\"id\":\"04c2ed32-9a8e-4d12-b0f6-9593a19515dd\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Lexical Hierarchy\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\": By walking the namespace string (using \",\"styles\":{}},{\"type\":\"text\",\"text\":\".rfind('.')\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\"), the manager can reconstruct the project's structure without needing to store complex tree pointers for every scope.\",\"styles\":{}}],\"children\":[]},{\"id\":\"b544eb13-4a93-481e-92d9-1fd5969da202\",\"type\":\"bulletListItem\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Safety Fallbacks\",\"styles\":{\"bold\":true}},{\"type\":\"text\",\"text\":\": Methods like \",\"styles\":{}},{\"type\":\"text\",\"text\":\"helper\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" and \",\"styles\":{}},{\"type\":\"text\",\"text\":\"get_final_pointName\",\"styles\":{\"code\":true}},{\"type\":\"text\",\"text\":\" ensure that the analysis doesn't return null results for unresolved symbols, providing the symbol's own name as a default to maintain continuity in the data-flow graph.\",\"styles\":{}}],\"children\":[]},{\"id\":\"41764531-0667-4c43-bee6-7f6e3e15d320\",\"type\":\"paragraph\",\"props\":{\"backgroundColor\":\"default\",\"textColor\":\"default\",\"textAlignment\":\"left\"},\"content\":[],\"children\":[]}]"
  }
]